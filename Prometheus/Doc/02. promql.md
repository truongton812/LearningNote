# PromQL (Prometheus Query Language)

## 1. PromQL data type
Trong PromQL có 4 kiểu dữ liệu cơ bản:
- Instance vector: Tập hợp nhiều time series, mỗi time series chỉ lấy giá trị tại một thời điểm cụ thể, giá trị này là giá trị gần nhất thời điểm truy vấn mà được lưu trong timeseries database. Đây là kiểu dữ liệu trả về khi truy vấn tên metric hoặc filter bằng label, ví dụ: `wmi_logical_disk_free_bytes` hoặc `node_cpu_seconds_total{mode="idle"}`

  Lưu ý là instance vector có thể truy vấn được thời gian là 1 thời điểm cụ thể, không nhất thiết phải là hiện tại. Cách thực hiện: truy vấn tên metric, sau đó chọn thời điểm quá khứ cần xem (ví dụ: 2023-12-18 14:00:00), xong Bấm "Execute", Prometheus sẽ trả về giá trị instance vector tại thời điểm bạn vừa chọn

  Ứng dụng: Dùng để hiển thị snapshot (trạng thái hiện tại) của các metric, ví dụ như CPU usage tại thời điểm hiện tại.

- Range vector: là tập hợp các time series mà trong đó mỗi time series chứa nhiều giá trị dữ liệu trong một khoảng thời gian xác định (ví dụ: 5 phút gần nhất). Đây là kiểu dữ liệu trả về khi truy vấn tên metric metric hoặc filter bằng label và kèm theo [thời lượng] vào metric , ví dụ `http_requests_total[5m]` hoặc `node_cpu_seconds_total{mode="idle"}[5m]` . Nếu scrape_interval là 15s thì kết quả trả về mỗi time series sẽ có 20 samples
  
  Ứng dụng: Dùng để phân tích xu hướng, tính toán rate, average, phát hiện anomaly hoặc tổng hợp dữ liệu trên một quãng thời gian.
  
  Lưu ý: Ta không thể tạo graph của range vector

- Scalar: một giá trị số thực (floating point) đơn lẻ tại một thời điểm, thường dùng trong biểu thức điều kiện hoặc phép tính.
- String: một chuỗi ký tự, ít sử dụng trong kết quả truy vấn thông thường của PromQL, chủ yếu sử dụng làm label, hoặc hiển thị metadata, ví dụ như giá trị label (job="api").


## 2. Các công cụ trong ngôn ngữ truy vấn Prometheus Query Language (PromQL)

### 2.1. Matcher

Matcher là điều kiện (bộ lọc) áp dụng trên label của time series trong selector để chỉ lấy ra các chuỗi dữ liệu phù hợp. Matcher thường đi kèm trong dấu ngoặc nhọn {} và có 4 loại:

- Quality matcher (=): match chính xác label, lưu ý kiểu này có tính đến case sensitive

VD: `process_cpu_seconds_total{job='node_exporter', instance='localhost:9100'}` 

-> kết quả trả về giá trị hiện tại (tức thời điểm bạn truy vấn) của tất cả các time series mà có cả 2 nhãn `job='node_exporter'` và `instance='localhost:9100'` từ metric process_cpu_seconds_total. Lưu ý là nếu một time series cùng có 2 nhãn này và thêm các nhãn khác nữa, nó vẫn được đưa vào kết quả truy vấn.

Kết quả có thể là:
```
process_cpu_seconds_total{job="node_exporter", instance="localhost:9100", cpu="0"} 1234.5
process_cpu_seconds_total{job="node_exporter", instance="localhost:9100", cpu="1"} 5678.9
```

- Negative equality matcher (!=): match các label khác với chỉ định
- Regular expression matcher (&#61;&#126;): select label theo dạng regex.

  VD: `prometheus_http_requests_total{handler=~”/api.*”}` -> trả về tất cả các timeseries có label là `handler` bắt đầu bằng `/api`
- Negative regular expression matcher (!~): không match label theo dạng regex


### 2.2. Operators

Là các ký hiệu hoặc từ khóa đại diện cho các phép toán hoặc thao tác xử lý dữ liệu được áp dụng lên metric hoặc tập hợp dữ liệu time series. Operator được dùng để kết hợp, so sánh hoặc tính toán giữa các metric hoặc giá trị, giúp truy vấn dữ liệu theo cách mong muốn. Có 2 loại operator là binary operators và aggregation operators

##### 2.2.1 Binary operators 

Là operator tính toán dựa trên 2 operands (toán tử). Có 3 loại binary operator:

- Arithmetic binary operator: là các phép tính +, -, *, /, %, ^. Được dùng giữa vector/scalar, vector/vector, scalar/scalar. VD: `node_memory_MemTotal_bytes/1024/1024`
  
- Comparison binary operator:  là các phép so sánh ==, !=, >, <, >=, <=. Được dùng giữa vector/scalar, vector/vector, scalar/scalar, thường được dùng để làm cảnh báo, VD khi CPU vượt quá 500 `node_cpu_seconds_total > 500`
  
- Logical binary operator: là các phép logic and, or, unless. Chỉ được dùng giữa instant vectors.
  
	- And: Trả về các time series mà cùng tồn tại (match) ở cả hai vector bên trái và bên phải dựa trên tập nhãn giống nhau. Cách hoạt động: Nếu một time series ở vector bên trái có cùng bộ label với một time series ở vector bên phải, giá trị sẽ được giữ lại ở kết quả. Nếu không có cặp nào khớp label giữa hai bên, time series đó bị loại khỏi kết quả.
   
        VD: `up{job="api"} and http_requests_total{job="api"}`
   
        -> Chỉ những time series của metric up có nhãn job="api" mà đồng thời cũng xuất hiện ở metric http_requests_total (tức khớp nhãn giữa hai bên) mới được hiển thị

	- Or: Kết hợp các time series từ cả hai phía, giữ lại toàn bộ series xuất hiện ở bất kỳ bên nào. Cách hoạt động: Nếu time series chỉ xuất hiện ở một bên, vẫn được đưa vào kết quả. Nếu cùng nhãn xuất hiện ở cả hai metric, giá trị lấy từ bên trái.

        VD: `http_requests_total{status="200"} or http_requests_total{status="500"}`

        -> Kết quả bao gồm cả những time series có status là 200 hoặc 500, không bỏ sót cái nào
   

    Khi dùng logical binary operator có thể kết hợp thêm ignoring và on  

    - ignoring (\<label list>): dùng để loại bỏ các nhãn chỉ định trong danh sách ra khỏi quá trình so khớp vector. Nghĩa là tất cả các nhãn trừ những nhãn ignoring sẽ được dùng để so khớp.

      VD1: `prometheus_http_requests_total and ignoring(handler) promhttp_metric_handler_requests_total`

      -> trả về các time series thuộc metric prometheus_http_requests_total mà (ngoại trừ nhãn handler) có bộ nhãn trùng khớp với bất kỳ time series nào của metric promhttp_metric_handler_requests_total. Kết quả là giá trị của metric bên trái – tức chỉ các series từ prometheus_http_requests_total, nhưng chỉ giữ lại những series mà (ngoại trừ nhãn handler) cũng có xuất hiện ở promhttp_metric_handler_requests_total

      VD2: `sum(http_requests_total) by (job, status) + ignoring(status) sum(http_errors_total) by (job, status)`

      -> Phép cộng sẽ thực hiện mà bỏ qua nhãn status, chỉ matching dựa trên các nhãn còn lại
  
    - on (\<label list>): chỉ dùng các nhãn được chỉ định trong danh sách để ghép các time series giữa hai bên. Những nhãn không nằm trong danh sách sẽ bị bỏ qua khi so khớp.

      VD1: `prometheus_http_requests_total and on(code) promhttp_metric_handler_requests_total`

      -> Kết quả truy vấn là các time series thuộc metric prometheus_http_requests_total mà trường code trùng khớp với ít nhất một time series của metric promhttp_metric_handler_requests_total. Toàn bộ nhãn và giá trị của phía trái được giữ nguyên

      VD2: `sum(http_requests_total) by (method) / on(method) sum(http_response_time_seconds) by (method)`

      -> Biểu thức này chia tổng số requests cho tổng response time, ghép cặp dựa trên nhãn method


##### 2.2.2. Aggregation operators

Là các toán tử dùng để tổng hợp và xử lý các time series thành một vector mới, thường là với kích thước nhỏ hơn. Cách hoạt động cơ bản của aggregation operators là lấy một instant vector chứa nhiều time series và tính toán kết quả trên toàn bộ hoặc nhóm các time series theo label cụ thể. Ví dụ, với metric http_requests có nhiều nhãn như method, path, bạn có thể tính tổng số request hoặc trung bình request trên tất cả các nhãn hoặc nhóm theo 1 nhãn cụ thể. 
Lưu ý: Aggregation operators chỉ áp dụng với "instant vector"
      
Các aggregation operator type:
- sum: Tính tổng các giá trị của các chuỗi time series. Ví dụ: `sum(prometheus_http_requests_total) by (code)` -> tính tổng http request theo từng loại code label
- avg: Tính giá trị trung bình. Ví dụ: `avg(cpu_usage)`
- min / max: Lấy giá trị nhỏ nhất/lớn nhất trong nhóm. Ví dụ: `min(node_memory_MemFree_bytes)`, `max(node_memory_MemFree_bytes)`
- count: Đếm số lượng time series. Ví dụ: `count(up)`
- count_values: Đếm số lần xuất hiện của mỗi giá trị cụ thể trong time series và trả về thành từng nhóm theo value.
- stddev, stdvar: Tính độ lệch chuẩn (standard deviation) và phương sai (variance).
- quantile: Tính giá trị percentile mong muốn (ví dụ: median, 95th).
- topk(k, metric): Lấy k giá trị lớn nhất. VD: `topk(3, sum(node_cpu_seconds_total) by (mode))`: lấy ra 3 mode cpu có time cao nhất
- bottomk(k, metric): Lấy k giá trị nhỏ nhất.
- group: Gom nhóm các time series mà không quan tâm đến giá trị, mỗi nhóm luôn trả về 1 (dùng cho các tình huống kiểm tra sự tồn tại).

Cách sử dụng aggregation operator với by và without
- by (label): Gom nhóm theo một hoặc nhiều nhãn; kết quả giữ lại các nhãn này. VD: `sum by(instance) (node_cpu_seconds_total)` -> Cộng dồn cpu theo từng instance
- without (label): Gom nhóm và loại bỏ các nhãn chỉ định khỏi kết quả. VD: `max without(mode) (node_cpu_seconds_total)` -> Lấy giá trị max, loại bỏ nhãn "mode"


### 2.3. Function

PromQL cung cấp rất nhiều function giúp xử lý, phân tích, và tổng hợp dữ liệu time series. Các function này có thể chia thành các nhóm chính:

##### 2.3.1. Hàm tính toán tốc độ, biến động
- rate(): Tính tốc độ tăng trung bình trên giây của một counter trong 1 khoảng thời gian, chỉ áp dụng với metric kiểu counter. Hàm rate giúp ta nắm được xu hướng của metric đang tăng nhanh hay châm, điều mà bản thân counter metric không thể hiện được. VD khi query metric prometheus_http_requests_total thì sẽ nhận được giá trị số lượng http request gần nhất, giá trị đấy không thể hiện được xu hướng do số lượng http request là 1 số luôn tăng -> rate giúp biết được tốc độ tăng http_request là nhanh hay chậm: `rate(prometheus_http_requests_total[1m])` để tính ra trong 1 giây có bao nhiêu http request, với range là hiện tại đến 1’ trước

  Rate() còn giúp tạo graph cho range vector do output của rate() là instance vector, và Prometheus chỉ có thể tạo graph của instance vector

  Giải thích thêm về cách tạo graph của hàm rate()

  Khi bạn query: rate(http_requests_total[3m]) Prometheus sẽ tính tốc độ trung bình trên mỗi giây của metric http_requests_total trong từng cửa sổ 3 phút kết thúc lần lượt tại mỗi điểm sampling 12:00, 12:01, 12:02, ... Và nếu ta set step trong graph là 1 phút (60s) thì kết quả sẽ là:

  - Cửa sổ tại 12:00 sẽ tính dựa trên dữ liệu từ 11:57 đến 12:00. -> điểm sampling tại thời điểm 12:00 trên đồ thị nhận giá trị này

  - Cửa sổ tại 12:01 sẽ tính dựa trên dữ liệu từ 11:58 đến 12:01. -> điểm sampling tại thời điểm 12:01 trên đồ thị nhận giá trị này

  - Cửa sổ tại 12:02 sẽ tính dựa trên dữ liệu từ 11:59 đến 12:02. -> điểm sampling tại thời điểm 12:02 trên đồ thị nhận giá trị này

- irate(): Tốc độ tăng tức thời (tính theo hai điểm dữ liệu gần nhất). Irate dùng để tạo graph của fast moving counter
- changes: dùng tính số lần thay đổi của 1 metric, thường chỉ dùng với các metric ít thay đổi. VD: `changes(process_start_time_second{job='node_exporter'}[1h]` -> tính xem trong 1 giờ process "node exporter" restart bao nhiêu lần
- deriv(): dùng để tính xem 1 gauge metric thay đổi nhanh hay chậm. Có thể xem như là hàm rate() áp dụng cho gauge metric. VD: `deriv(process_resident_memory_bytes{job='prometheus'}[1h])` -> tính tốc độ thay đổi bộ nhớ thực tế (bytes trên giây) mà tiến trình Prometheus đang sử dụng trong 1 giờ gần nhất
- predict_linear(): Dự đoán giá trị sau một thời gian dựa trên xu hướng hiện tại. VD: `predict_linear(my_metric[10m], 30)` -> Dự đoán giá trị metric my_metric trong 30 giây tiếp theo dựa trên dữ liệu 10 phút trước đó.
- increase(): Tổng mức tăng của counter trong một khoảng thời gian.
- delta(): Thay đổi tuyệt đối của gauge trong một period nhất định.

##### 2.3.2. Hàm tổng hợp, thống kê trên cửa sổ thời gian

Đây bản chất là các aggregation operator tuy nhiên có thể sử dụng cho range vector

- avg_over_time(): Giá trị trung bình trong một khoảng thời gian.
- sum_over_time(): Tổng giá trị.
- min_over_time(), max_over_time(): Giá trị nhỏ nhất/lớn nhất. VD: `max_over_time(node_cpu_seconds_total[1h]}` -> trả về giá trị lớn nhất của từng time series của metric node_cpu_seconds_total trong vòng 1 giờ gần nhất
- count_over_time(): Số lượng sample có trong khoảng thời gian.
- quantile_over_time(): Tính percentile (như median, 95th percentile).
- stddev_over_time(), stdvar_over_time(): Độ lệch chuẩn/phương sai.

##### 2.3.3. Hàm xử lý instance vector:
- sort(): sắp xếp các time series theo thứ tự tăng dần của value
- sort_desc(): sắp xếp các time series theo thứ tự giảm dần của value
- sort_by_label()

##### 2.3.4. Hàm phân tích histogram
- histogram_quantile(): Tính giá trị percentile (ví dụ P99, P95) từ metric dạng histogram bucket. Ví dụ: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))

##### 2.3.5. Hàm biến đổi, toán học
- abs(): Giá trị tuyệt đối.
- ceil(), floor(): Làm tròn lên/xuống.
- sqrt(): Căn bậc hai.
- clamp_min(), clamp_max(), clamp(): Giới hạn giá trị nhỏ nhất, lớn nhất, hoặc trong khoảng.
- round(): Làm tròn tới số lẻ đã chỉ định.

##### 2.3.6. Hàm thao tác label/metadata
- label_join(), label_replace(): Nối, thay thế các giá trị nhãn (label) thành nhãn mới.
- absent(): Kiểm tra một metric có xuất hiện hay không.
- absent_over_time(): Check metric có vắng mặt liên tục trong một khoảng thời gian.

##### 2.3.7. Hàm ngày, giờ
- year(), month(), day_of_month(), days_in_month(), day_of_week(), hour(), minute(), second(), timestamp(), time(),  : Trích xuất thông tin thời gian từ time series hoặc hệ thống.

##### 2.3.8. Hàm đặc biệt cho advanced use
- present_over_time(): Trả về 1 nếu có sample ở trong khoảng thời gian.
- resets(): Đếm số lần counter bị reset.
- last_over_time(): Giá trị sample cuối cùng trong khoảng thời gian.


## 3. Metric type

Trong Prometheus, có 4 kiểu metric chính là Counter (Bộ đếm), Gauge (Đồng hồ đo), Histogram (Biểu đồ phân phối) và Summary (Tóm tắt)

### 3.1. Counter
  Là loại metric dùng để đếm số lượng sự kiện, chỉ tăng và không giảm (ngoại trừ khi khởi động lại sẽ về 0). Ví dụ: số lượng yêu cầu HTTP đã xử lý, số lượng request, số lượng task hoàn thành, số lượng lỗi. Counter chỉ có 1 method là inc(). Default là tăng 1 đơn vị tuy nhiên có thể thay đổi

### 3.2. Gauge
  Là loại metric giữ giá trị hiện tại, có thể tăng hoặc giảm tùy tình trạng thực tế, ví dụ như nhiệt độ, số RAM hiện đang sử dụng, số lượng thread đang chạy hoặc số lượng kết nối hiện tại Gaguge có 3 methods là inc(), dec() và set(). Default là tăng, giảm hoặc set 1 đơn vị tuy nhiên có thể custom

### 3.3. Summary

  Là một loại metric dùng để theo dõi và đo lường các dữ liệu dạng phân phối như độ trễ, thời gian hoàn thành một task hoặc kích thước của các sự kiện. 
  
  Summary rất hữu ích khi cần đo chính xác các thông số phân phối thời gian hoặc kích thước, ví dụ khi theo dõi độ trễ một request HTTP, Summary có thể cung cấp thông tin về độ trễ trung bình, độ trễ lớn nhất, và các phần trăm phân vị như 90%, 99% của độ trễ, giúp dễ dàng đánh giá hiệu suất.

  Một metric loại summary sẽ lấy các samples (mẫu dữ liệu) từ những observations (giá trị quan sát được) để tổng hợp lại. Observations có thể là request duration (thời gian app phản hồi cho request), latency, request size,... Summary có 1 method là observer(), ta pass size của event làm parameter cho method này. Summary lưu lại hai giá trị chính là count (tổng số sự kiện quan sát được) và sum (tổng giá trị của các sự kiện đó).

  Điểm khác biệt chính của Summary so với Histogram là Summary không phân loại dữ liệu thành các bucket (ngăn), thay vào đó nó tính toán trực tiếp các giá trị tổng hợp quan trọng như tổng giá trị, số lượng sự kiện, trung bình, max, min và phần trăm phân vị (quantiles).
  
### 3.4. Histogram

  Thu thập các giá trị quan sát được và phân phối vào các bucket (khoảng) để thống kê phân bố, ví dụ như thời gian phản hồi của một dịch vụ.  Mục đích chính của histogram là tính toán quantiles. Histogram cũng lưu lại hai giá trị chính là count và sum.. Histogram lấy các samples từ observations (có thể là request duration or response size,..) và phân loại dữ liệu vào các buckets). Instrumentation cho histogram giống với summary. 
     
Ngoài expose ra 2 metric là _sum và _count giống Summary, Histogram còn expose ra các metric có đuôi là _bucket. Mỗi bucket trong histogram là một bộ đếm ghi lại số lượng các event có giá trị nhỏ hơn hoặc bằng giới hạn trên (le) của bucket đó. Vì các bucket này tích lũy (cumulative), mỗi bucket bao gồm số lượng event từ bucket trước đến bucket hiện tại, tạo thành một biểu đồ phân phối tích lũy. Qua đó, histogram giúp phân loại và đánh giá phân bố các sự kiện như latency của request một cách trực quan và hiệu quả.

## 4. Prometheus client library

  Thư viện prometheus_client trong Python là một client chính thức giúp ứng dụng của bạn xuất các chỉ số (metrics) theo định dạng mà hệ thống giám sát Prometheus hiểu được. Nói cách khác, nó dùng để tích hợp đo lường (instrumentation) trực tiếp vào code của ứng dụng nhằm tạo ra các metric như counter (bộ đếm), gauge (giá trị đo lường có thể tăng giảm), histogram (thống kê phân phối giá trị) để Prometheus có thể thu thập.

  Với prometheus_client bạn có thể:

- Định nghĩa các loại metric để theo dõi các thông số quan trọng (ví dụ: số lượng request HTTP, thời gian xử lý request, số lượng người dùng hiện tại, v.v).

- Khởi động một HTTP server riêng trên một cổng để Prometheus chủ động gửi request thu thập các chỉ số (mô hình pull).

- Tăng hoặc cập nhật các giá trị metric trong ứng dụng một cách dễ dàng chỉ với vài dòng code.

Thư viện này hỗ trợ rất tốt cho việc giám sát hiệu năng, tình trạng hoạt động của ứng dụng, giúp lập trình viên và đội ngũ vận hành dễ dàng nắm bắt các số liệu từ ứng dụng để cảnh báo hoặc phân tích sau này.

Lưu ý cách đặt metric cho các hệ thống:

- Online-serving system: là hệ thống mà người gọi đến kỳ vọng được phản hồi ngay lập tức. VD web, database,... Ta cần giám sát các metric như request rate, latency, error rate, in-progress requests
  
- Offline-processing system: không có ai chờ phản hồi. VD hệ thống xử lý log. Cần giám sát các metric: số lượng incoming items, số lượng đang được xử lý, lần cuối xử lý, số lượng item được gửi ra, số lượng error
  
- Batch jobs: giống với offline-processing system, chỉ khác là batch job chạy định kỳ chứ không liên tục. Batch job thường được dùng với push gateway. Cần giám sát các metric: chạy trong bao lâu, lần cuối completed (cả successful và failed)
  
### 4.1 Code app python để expose counter metric
```python
import http.server
import random
from prometheus_client import start_http_server, Counter #start_http_server class dùng để khởi tạo http server để expose metric. Counter class dùng để tạo metric type là counter 

REQUEST_COUNT = Counter('app_requests_count', 'total app http request count',['app_name', 'endpoint']) #ý nghĩa các parameter: tên metric, help string, list các label
RANDOM_COUNT = Counter('app_random_count','increment counter by random value')

APP_PORT = 8000
METRICS_PORT = 8001

class HandleRequests(http.server.BaseHTTPRequestHandler):

    def do_GET(self):
        REQUEST_COUNT.labels('prom_python_app', self.path).inc() #đặt counter metric ở trong function để đếm xem code block do_GET(self) này được requested bao nhiêu lần. Số lần code block này được gọi sẽ tương ứng với số lần main url của ứng dụng này được gọi, do mỗi khi main url được gọi thì code block này sẽ được thực thi.
        #Các param trong label là value của label, tương ứng với các key app_name và endpoint khai báo ở trên. Self.path sẽ trả về metric cho từng code path, nếu không khai báo label self.path thì chỉ có 1 time series đếm tổng số request vào website, bất kể code path là gì
        #Trong thực tế ta có thể đặt counter ở bất kỳ code path nào ta muốn track
	#REQUEST_COUNT ở đây là object, và class counter chỉ có 1 method là inc() 
        random_val = random.random()*10
        RANDOM_COUNT.inc(random_val) # bước nhảy có thể là số dương bất kỳ, không nhất thiết phải bằng 1
        
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(bytes("<html><head><title>First Application</title></head><body style='color: #333; margin-top: 30px;'><center><h2>Welcome to our first Prometheus-Python application.</center></h2></body></html>", "utf-8"))
        self.wfile.close()

if __name__ == "__main__":
    start_http_server(METRICS_PORT)
    server = http.server.HTTPServer(('localhost', APP_PORT), HandleRequests)
    server.serve_forever()
```
Counter metric thường dùng để đếm số lượng http request, số lượng visitor vào website, số lượng code block được thực thi

### 4.2. Code app python để expose gauge metric

```python
import http.server
import random
import time
from prometheus_client import start_http_server, Gauge

REQUEST_INPROGRESS = Gauge('app_requests_inprogress','number of application requests in progress')
REQUEST_LAST_SERVED = Gauge('app_last_served', 'Time the application was last served.')

APP_PORT = 8000
METRICS_PORT = 8001

class HandleRequests(http.server.BaseHTTPRequestHandler):

    @REQUEST_INPROGRESS.track_inprogress() #do việc đếm số progress đang trong quá trình xử lý là phổ biến nên Class Gauge đưa ra 1 method là track_inprogress, method này tương đương với việc dùng 2 method inc() và des()
    def do_GET(self):
       # REQUEST_INPROGRESS.inc() #đặt hàm tăng ở đây để tăng lên 1 đơn vị khi bắt đầu xử lý code
        time.sleep(5)
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(bytes("<html><head><title>First Application</title></head><body style='color: #333; margin-top: 30px;'><center><h2>Welcome to our first Prometheus-Python application.</center></h2></body></html>", "utf-8"))
        self.wfile.close()
        REQUEST_LAST_SERVED.set_to_current_time() #do việc set thời gian là phổ biến nên Class Gauge đưa ra 1 method là set_to_current_time, method này tương đương với việc dùng method set(time.time())
       # REQUEST_LAST_SERVED.set(time.time()) #hàm set dùng để set value cho metric REQUEST_LAST_SERVED
       #REQUEST_INPROGRESS.dec() #đặt hàm giảm ở đây để giảm đi 1 đơn vị khi xử lý xong code

if __name__ == "__main__":
    start_http_server(METRICS_PORT)
    server = http.server.HTTPServer(('localhost', APP_PORT), HandleRequests)
    server.serve_forever()
```
### 4.3. Code app python để expose summary metric

```python
import http.server
import time
from prometheus_client import start_http_server, Summary

REQUEST_RESPOND_TIME = Summary('app_response_latency_seconds', 'Response latency in seconds')

APP_PORT = 8000
METRICS_PORT = 8001

#để xác định thời gian app xử lý request thì ta lấy thời gian app xử lý xong trừ đi thời gian app bắt đầu xử lý
class HandleRequests(http.server.BaseHTTPRequestHandler):

    @REQUEST_RESPOND_TIME.time() #do việc track respond time là phổ biến nên Class Summary đưa ra 1 method là time, method này tương đương với việc tính toán thủ công ở dưới
    def do_GET(self):
        #start_time = time.time() #lấy thời gian app bắt đầu xử lý request
        time.sleep(6)
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(bytes("<html><head><title>First Application</title></head><body style='color: #333; margin-top: 30px;'><center><h2>Welcome to our first Prometheus-Python application.</center></h2></body></html>", "utf-8"))
        self.wfile.close()
        #time_taken = time.time() - start_time #tính thời gian app cần để xử lý request
       # REQUEST_RESPOND_TIME.observe(time_taken) #lưu giá trị time_taken vào summery metric bằng method observe


if __name__ == "__main__":
    start_http_server(METRICS_PORT)
    server = http.server.HTTPServer(('localhost', APP_PORT), HandleRequests)
    server.serve_forever()
```
### 4.4. Code app python để expose histogram metric
```python
import http.server
import time
from prometheus_client import start_http_server, Histogram

REQUEST_RESPOND_TIME = Histogram('app_response_latency_seconds', 'Response latency in seconds', buckets=[0.1,0.5,1,2,3,4,5,10]) #para bucket dùng để custom size của bucket, không dùng default bucket của prometheus

APP_PORT = 8000
METRICS_PORT = 8001

class HandleRequests(http.server.BaseHTTPRequestHandler):

    @REQUEST_RESPOND_TIME.time()
    def do_GET(self):
        #start_time = time.time()
        time.sleep(1)
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(bytes("<html><head><title>First Application</title></head><body style='color: #333; margin-top: 30px;'><center><h2>Welcome to our first Prometheus-Python application.</center></h2></body></html>", "utf-8"))
        self.wfile.close()
        #time_taken = time.time() - start_time
        REQUEST_RESPOND_TIME.observe(time_taken)


if __name__ == "__main__":
    start_http_server(METRICS_PORT)
    server = http.server.HTTPServer(('localhost', APP_PORT), HandleRequests)
    server.serve_forever()
```
