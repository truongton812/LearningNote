Lập trình hướng đối tượng (Object-Oriented Programming, viết tắt OOP) là một phương pháp lập trình dựa trên khái niệm đối tượng, giúp mô hình hóa các đối tượng ngoài đời thực thành các thành phần trong phần mềm, giúp quản lý mã nguồn hiệu quả và dễ mở rộng.

Đối tượng và lớp

- Lớp (class) là mô hình hoặc khuôn mẫu để tạo ra các đối tượng. Đối tượng là thực thể cụ thể của lớp.

  Cách khai báo lớp
  ```
  class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print("Hello, tôi là", self.name)
  ```
- Đối tượng là đơn vị cơ bản trong OOP, chứa dữ liệu (thuộc tính) và hành động (phương thức).

Tạo đối tượng (hay còn gọi là thể hiện của lớp) từ lớp. Có thể tạo nhiều đối tượng từ 1 lớp

```
person1 = Person("An", 22)
person1.greet()  # Kết quả: Hello, tôi là An
```
print(person1) -> output là <__main__.Person object at 0xx0002528989C0..> #at 0xxx... là vị trí của đối tượng lưu trong bộ nhớ
print(type(person1)) -> output là <class '__main__.Person'>

Trong python, các đối tượng đều thuộc lớp cơ sở hoặc lớp ta tự định nghĩa

VD: n = 10; #n chính là thể hiện của class int
print(type(n)) -> output là <class 'int'>

#### Các khái niệm
##### Thuộc tính của đối tượng
Thuộc tính của đối tượng là các biến được định nghĩa bên trong lớp. Trong một lớp có thể khai báo nhiều thuộc tính

VD:
```
class Car:
  sound = "beep"
  color = "red"
```
Thì khi khai báo đối tượng ta có thể lấy ra các thuộc tính này
```
ford = Car()
print(ford.color) -> output là red
```
Lưu ý tất cả các đối tượng được tạo ra từ cùng 1 lớp sẽ có các thuộc tính giống nhau
VD bmw = Car() -> print(bmw.color) cũng là red


Ta có thể thay đổi thuộc tính của đối tượng để custom đối tượng theo ý muốn (có thể xem như thuộc tính khai báo trong lớp là default)
VD:
```
ford.color = 'blue'
print(ford.color) -> output sẽ là blue thay vì red như trước
```


Thay vì phải thay đổi thuộc tính của đối tượng như cách trên, ta có thể truyền thuộc tính vào cho đối tượng từ lúc ta khởi tạo đối tượng


class Car:
  def __init__(self,`color`): #self nghĩa là đang tham chiếu đến chính lớp hiện tại (có vẻ như trong lớp này có thể tham chiếu được đến thuộc tính của lớp khác, cần check lại)
    self.color = `color` -> 2 color này phải giống nhau, còn self.color hay self.abc gì cũng được

Fact: nếu ở trên dùng self.color = 'blue' thì thuộc tính color của đối tượng luôn là blue, dù cho ta có khởi tạo đối tượng như thế nào đi nữa. VD khởi tạo đối tượng ford=Car(green) thì ford.color vẫn là blue

Khời tạo đối tượng và truyền thuộc tính
```
ford = Car('green')
print(ford.color) -> output là green
```
Phương thức init trong lập trình được gọi là constructor, sẽ được tự động gọi khi ta khởi tạo đối tương (phương thức là hàm trong class)
Xem thêm giải thích hàm __init__ ở đây https://www.perplexity.ai/search/giai-thich-cau-truc-1-file-cod-ktHndOljR2.1AkfPKKk91A

##### Thuộc tính toàn cục và thuộc tính thể hiện

```
class Car:
  sound = "beep"
  def __init__(self,color):
    self.color="blue"
```

print(Car.sound) -> output là "beep". Chứng tỏ lớp Car có thể truy cập trực tiếp vào thuộc tính sound mà không cần khởi tạo đối tượng. Lý do là khi khai báo biến sound không nằm trong phương thức init như vậy thì đấy sẽ là thuộc tính toàn cục, có thể truy cập trực tiếp bằng lớp

print(Car.color) -> sẽ báo lỗi, do color là thuộc tính thể hiện (được định nghĩa trong hàm init), chỉ có thể truy xuất khi tạo đối tượng

##### Phương thức của đối tượng

Là các hàm được định nghĩa trong class.  Trong một lớp có thể khai báo nhiều phương thức. VD
```
class Dog:
  def makeSound(self):
    print("gow")
  def greet(self):
    print("hello")
adog = Dog()
adog.makeSound() -> output là "gow"
adog.greet() -> output là hello
```

Lưu ý từ nếu không có từ khóa self ở trên thì phương thức sẽ chỉ có thể truy cập thông qua tên lớp chứa nó chứ không thể truy cập thông qua đối tượng. Nghĩa là chỉ có thể gọi Dog.makeSound()

Tóm lại nếu muốn đối tượng truy cập được phương thức thì phải có từ khóa self


Ví dụ khác
```
class Dog:
    sound = "bark"
    def makeSound(self): # self là cách để phương thức của lớp biết về đối tượng cụ thể mà nó đang thao tác, là tham chiếu bắt buộc phải có trong định nghĩa phương thức của lớp để làm việc với dữ liệu của đối tượng ấy 
        print(self.sound) 
b = Dog()
b.makeSound()
```

Giải thích về từ khóa self:

self đại diện cho đối tượng (instance) hiện tại của lớp khi phương thức được gọi. Nó cho phép truy cập các thuộc tính và phương thức của đối tượng đó. Lưu ý phần đầu tiên của tham số khi khai báo phương thức luôn phải đại diện cho đối tượng gọi nó. (tức self)

Khi gọi phương thức bằng cách b.makeSound(), đối tượng b sẽ được truyền ngầm như đối số đầu tiên cho phương thức makeSound(self).

Do đó, trong makeSound(self), self.sound trỏ đến thuộc tính sound của đối tượng b, tức là giá trị "bark".


Ví dụ ta tạo 1 đối tượng khác và gán cho nó thuộc tính khác

c = Dog()
c.sound = "gau gau"
c.makeSound() -> output là "gau gau" chứ không phải "bark" nữa, do self giúp phương thức makeSound biết đối tượng nó đang thao tác là c, có thuộc tính sound là "gau gau"

#### Các đặc tính chính

OOP có bốn đặc tính cơ bản:

Tính đóng gói: Che giấu thông tin bên trong đối tượng, chỉ cho phép truy xuất qua các phương thức công khai.

Tính kế thừa: Lớp con có thể kế thừa thuộc tính và phương thức từ lớp cha, giúp tái sử dụng mã.

Tính đa hình: Một phương thức có thể có nhiều cách thực hiện khác nhau, tùy thuộc vào đối tượng cụ thể.

Tính trừu tượng: Chỉ thể hiện những gì cần thiết, che giấu chi tiết không liên quan.

Ưu điểm của OOP
Tổ chức mã nguồn rõ ràng, trực quan như thực tế

Dễ mở rộng, bảo trì và tái sử dụng

Tối ưu hóa quá trình phát triển phần mềm, giảm trùng lặp

Ví dụ minh họa
Lớp "Người" với thuộc tính (họ tên, tuổi) và phương thức (nói, đi lại). Từ lớp này, có thể tạo các đối tượng là từng người cụ thể với dữ liệu riêng biệt, nhưng cùng cách hoạt động chung

---

```python
#!/usr/bin/python

try:
    import json
except ImportError:
    import simplejson as json #import module json, nếu ko có thì import simplejson

from ansible.module_utils.basic import AnsibleModule #AnsibleModule là 1 module giúp parse argument pass vào cho custom module
import time
import sys

def main(): #Đây là main function, dùng AnsibleModule để lấy argument và gán cho biến "module". Argument_spec là set các argument cần cho custom module. Nếu ta cần nhiều argument hơn chỉ mỗi msg thì sẽ khai báo trong dict này
    module = AnsibleModule(
        argument_spec = dict(
            msg=dict(required=True, type='str')
        )
    )

    msg = module.params['msg'] #đọc nội dung của msg parameter bằng function module.params

    # Successfull Exit
    try:
        print(json.dumps({
            "msg": '%s - %s' % (time.strftime("%c"), msg),
            "changed": True
        }))
        sys.exit(0)
    except:
        # Fail Exit
        print(json.dumps({
            "failed": True,
            "msg": "failed debugging"
        }))

if __name__ == '__main__':
    main()

```

Cụm 

```
    # Successfull Exit
    try:
        print(json.dumps({
            "msg": '%s - %s' % (time.strftime("%c"), msg),
            "changed": True
        }))
        sys.exit(0)
    except:
        # Fail Exit
        print(json.dumps({
            "failed": True,
            "msg": "failed debugging"
        }))
```
Có thể thay thế bằng cách sử dụng module exit_json và fail_json của ansible
```
try:
    # Successfull Exit
    module.exit_json(changed=True, msg='!%s - %s' % (time.strftime("%c"), msg)) #module exit_json luôn thoát ra với exit code =0
except:
    # Fail Exit
    module.fail_json(msg="Error Message")  #module fail_json luôn thoát ra với exit code =1
```

---

Giải thích đoạn if __name__ == '__main__':
    main()
Đây là cách chuẩn trong Python để xác định rằng file code hiện tại đang được chạy trực tiếp bằng lệnh python tenfile.py chứ không phải bị import từ file khác.

Khi bạn chạy một file Python, Python sẽ tự đặt biến đặc biệt __name__ là "__main__" trong file đó.

Nếu file bị import vào một file khác dưới dạng module, __name__ sẽ bằng tên module, không phải "__main__".

Tức là Nếu file code có khai báo if __name__ == "__main__": thì có nghĩa là bạn chỉ có thể thực thi code trong phần này khi chạy trực tiếp file bằng lệnh python tenfile.py, chứ khi import file đó vào file khác thì đoạn code trong if __name__ == "__main__": sẽ không chạy
Do Khi bạn chạy một file Python trực tiếp (ví dụ python tenfile.py), Python sẽ gán biến đặc biệt __name__ cho file đó bằng giá trị chuỗi "__main__". Do đó, đoạn code trong if __name__ == "__main__": sẽ được thực thi.

Ngược lại, nếu bạn import file đó như một module trong file Python khác (ví dụ import tenfile), thì biến __name__ trong file tenfile.py sẽ không còn là "__main__" nữa mà sẽ là tên module là "tenfile". Lúc này, đoạn code trong if __name__ == "__main__": sẽ không được thực thi

Mục đích của Điều là này cho phép bạn viết code trong file vừa có thể tái sử dụng lại như module (với các hàm, lớp) mà không lo bị chạy đoạn mã kiểm thử hoặc khởi tạo khi import; đồng thời khi chạy trực tiếp file thì đoạn mã bên trong if __name__ == "__main__": sẽ là điểm bắt đầu chương trình.

Ví dụ

```
# tenfile.py
def func():
    print("Hàm func được gọi")

if __name__ == "__main__":
    print("File tenfile được chạy trực tiếp")
    func()
```
Nếu bạn chạy python tenfile.py, kết quả sẽ là:

```
File tenfile được chạy trực tiếp
Hàm func được gọi
```

Nếu bạn tạo file khác:

```
# main.py
import tenfile
```
và chạy python main.py, sẽ chỉ in ra gì? Không có gì, vì đoạn code trong if __name__ == "__main__": trong tenfile.py không được chạy khi import
