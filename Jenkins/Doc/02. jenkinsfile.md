Ưu tiên ${VAR} để tránh lỗi parsing và hỗ trợ nested variables (như ${env.BRANCH_NAME}).

Chỉ dùng $VAR trong pure shell commands nếu chắc chắn không xung đột. Trong Pipeline as Code, quy ước dùng ${} thống nhất giúp debug dễ dàng hơn


Luôn ưu tiên "${var}" trong steps để tránh lỗi parsing và hỗ trợ nested vars như "${env.BRANCH_NAME}".

${var} chỉ dùng trong pure Groovy script (script { def x = ${var} }), nhưng vẫn cần quote nếu trong string. Quy ước này giúp pipeline ổn định hơn trong môi trường shell phức tạp.


Cú pháp đúng: sh "echo ${BUILD_NUMBER}"



#### Giải thích chi tiết về Parameter

Parameter cho phép truyền các tham số người dùng vào thời điểm bắt đầu chạy pipeline  
<---> bổ sung thêm

## Environment
- Jenkins environment variables là các biến dạng key-value được Jenkins tự động cung cấp hoặc user định nghĩa. Có 3 loại env var:
  - Built-in var: Tự động tạo bởi Jenkins cho mọi build. VD: `BUILD_NUMBER`, `JOB_NAME`, `WORKSPACE`, `NODE_NAME`, `BRANCH_NAME`, `GIT_URL`, `GIT_COMMIT`,...
  - Global var: áp dụng cho tất cả pipeline trong Jenkins. Thêm ở **Manage Jenkins > Configure System > Global Properties**
  - Local var: chỉ áp dụng trong job/pipeline/stage cụ thể. Khai báo bằng chỉ thị `environment { MY_VAR = 'value' }` hoặc `withEnv()` cho scope tạm thời. Ví dụ
```
pipeline {
    environment { //Env dùng cho toàn bộ pipeline
        DB_HOST = 'localhost'
        VERSION = '1.0.0'
    }
    stages {
        stage('Build') {
			environment { //Env dùng cho stage
				TEST_ENV = 'staging'
			}
            steps {
                sh 'echo Using DB: $DB_HOST'
				withEnv(['API_KEY=secret123']) { //Env cho 1 scope tạm thời
				    sh 'curl -H "X-API-Key: $API_KEY" https://api.example.com'
				}
            }
        }
    }
}
```

- Cách Truy Cập Env Vars:​
  - Trong Shell: truy cập qua `$VAR_NAME`. VD `sh 'echo $BUILD_NUMBER'`​
  - Trong Groovy: truy cập qua `${env.VAR_NAME}` hoặc  `${VAR_NAME}`. VD `echo "${env.APP_VERSION}"`
  - Trong biểu thức điều kiện: `env.BRANCH_NAME`. VD `if (env.BRANCH_NAME == 'main')`

Ví dụ
```
pipeline {
    agent any
    environment {
        my_var = "hello"
    }
    stages {
        stage('Hello') {
            steps {
                // Gọi env bằng Groovy
                echo BUILD_NUMBER //Built-in variable của Jenkins
                echo my_var // Output là hello
                echo "${my_var}" // Output là hello
                echo env.my_var // Output là hello
                echo "${env.my_var}" // Output là hello
                echo "env.my_var ${env.my_var}" // Output là env.my_var hello
                echo "my_var ${my_var}" // Output là my_var hello

                // Gọi env trong shell
                sh 'echo $my_var' // Groovy không interpolates biến $my_var → Shell nhận câu lệnh là echo $my_var → tìm biến $my_var trong môi trường. Nếu không có sẽ trả về null, ở đây biến $my_var đã tồn tại do Groovy insert env vào shell hiện tại thông qua khai báo environment{} 
                sh 'echo "${my_var}"' // Groovy không interpolates → Shell nhận câu lệnh là echo "${my_var}" → tìm biến $my_var trong môi trường. Lưu ý ${my_var} = $my_var trong hầu hết trường hợp, nhưng ${} an toàn hơn khi cần rõ ràng boundary hoặc special cases
                sh "echo $my_var" // Groovy interpolates biến $my_var thành "hello" → Shell nhận câu lệnh là echo hello → Output là hello
                sh "echo env.my_var" //Output là env.my_var do đây không phải là cú pháp gọi env của Jenkins
                sh "echo $env.my_var" //Groovy interpolates biến $env.my_var thành "hello" → Shell nhận câu lệnh là echo hello → Output là hello
                sh "echo ${my_var}" //Groovy interpolates biến ${my_var} thành "hello" → Shell nhận câu lệnh là echo hello → Output là hello
            }
        }
    }
}
```
##### Scope của variable

Scope của variable trong Jenkins file có các điểm chính sau:
- Biến được khai báo bên trong một stage hoặc một node block chỉ có phạm vi (scope) trong block đó
- Nếu muốn biến dùng chung cho nhiều stage hoặc toàn pipeline, biến cần được khai báo bên ngoài các block đó, ví dụ ngay trong pipeline hoặc ở đầu Jenkinsfile.
- Biến khai báo trong một hàm hoặc closure có phạm vi nội bộ (local) của hàm đó, không thể truy cập bên ngoài trừ khi trả về.
- Có thể dùng từ khóa def để định nghĩa biến cục bộ trong phạm vi nhỏ, hoặc khai báo biến bên ngoài để biến toàn cục trong script.
- Trong scripted pipeline, biến toàn cục có thể dễ dàng được dùng lại giữa các bước, nhưng trong declarative pipeline cần chú ý cách và nơi khai báo để tránh lỗi phạm vi.

##### Dùng environment để lấy thông tin từ Credentials được lưu trong Jenkins config

Environment có thể giúp xử lý thông tin đăng nhập (credentials) một cách an toàn. Cụ thể trong phần khai báo biến môi trường (environment) của Jenkinsfile, có một phương thức đặc biệt gọi là credentials(). Phương thức này giúp lấy thông tin đăng nhập đã được Jenkins quản lý (được lưu trữ trong phần Credentials của Jenkins) một cách tiện lợi và an toàn.

Những loại thông tin đăng nhập được Jenkins hỗ trợ và có thể dùng với phương thức credentials() bao gồm:
- Secret Text: Văn bản bí mật như token hoặc mật khẩu ở dạng chuỗi.
- Secret File: Tệp bí mật, ví dụ file chứa khóa bảo mật.
- Username and password: Cặp tên người dùng và mật khẩu.
- SSH with Private Key: Khoá riêng SSH dùng để xác thực cho việc kết nối qua SSH.

Example

```Groovy
pipeline {
    agent any
    environment {
        // Lấy username và password từ Jenkins Credentials có ID 'my-credentials-id'
        MY_CREDENTIALS = credentials('my-credentials-id')
    }
    stages {
        stage('Example Username/Password') {
            environment {
                SERVICE_CREDS = credentials('my-predefined-username-password') // Environment có thể đặt trong khổi pipeline hoặc khối stages
            }
            steps {
                sh (script: """echo Service user is $SERVICE_CREDS_USR """, label: "description")
                sh 'echo "Service password is $SERVICE_CREDS_PSW"'
                sh 'curl -u $SERVICE_CREDS https://myservice.example.com'
                sh 'echo "Using username: $MY_CREDENTIALS_USR"'
                sh 'echo "Using password: $MY_CREDENTIALS_PSW"'
            }
        }
        stage('Example SSH Username with private key') {
            environment {
                SSH_CREDS = credentials('my-predefined-ssh-creds')
            }
            steps {
                sh 'echo "SSH private key is located at $SSH_CREDS"'
                sh 'echo "SSH user is $SSH_CREDS_USR"'
                sh 'echo "SSH passphrase is $SSH_CREDS_PSW"'
            }
        }
        stage('Example Secret Text or Secret File') {
            environment {
                SECRET_TOKEN = credentials('my-secret-token-id')
            }
		}
    }
}


```

- Conditional trong Jenkin: Cho phép ta điều khiển luồng chạy của pipeline  
VD1: chỉ chạy stage deploy khi branch là develop
```
Stages {
	stage(‘deploy’) {
		When {
			Branch ‘develop’
		}
		Steps { command }
	}
}
```  
VD2: chỉ chạy stage deploy khi thỏa mãn tất cả các điều kiện trong khối allOf (hoặc anyOf là chỉ cần thỏa mãn 1 trong các điều kiện)  
```
Stages {
	stage(‘deploy’) {
		When {
			allOf {
				Branch ‘develop’
				Environment name: “ten_bien”, value: “gia_tri_bien”
			}
		}
		Steps { command }
	}
}
```
- Stages và Parallel: Cho phép ta lựa chọn thứ tự xử lý các task.  
    + Stages: xử lý tuần tự các task  
    + Parallel: xử lý đồng thời các task  

Các khối stages và parallel có thể nằm lồng trong nhau, tuy nhiên không thể tạo 1 khối parallel bên trong 1 khối stage mà khối stage đó đang nằm trong khối parallel khác  
VD1: 
```
Stages {
	stage(‘Read file’) {
		stages {
			stage(‘1’) {
				Steps{command}
			}
			stage(‘2){
				Steps{command}
			}
		}
	}
}
```
VD2:
```
Stages {
	stage(‘Build in’) {
		parallel {
			stage(‘1’) {
				Steps{command}
			}
			stage(‘2){
				Steps{command}
			}
		}
	}
}
```
- Tạo giai đoạn cuối cho mỗi pipeline (post-build actions): Cho phép ta tạo ra 1 bước cuối cùng ở mỗi stage/pipeline/. Thông thường, để dọn dẹp hoặc để gửi mail/notification thông báo là pipeline đã chạy xong. Khối post này có thể nằm trong khối stages, stage, pipeline,...

VD: Luôn hiển thị dòng finish kể cả có lỗi hay không
```
post {
	Always {
		Echo “finish”
	}
}
```
Ngoài always còn có changed, fixed, regression, aborted, failure, success, unstable, unsuccessful, and cleanup.  

`changed`  
Only run the steps in post if the current Pipeline’s run has a different completion status from its previous run.  
`fixed`  
Only run the steps in post if the current Pipeline’s run is successful and the previous run failed or was unstable.  
`regression`  
Only run the steps in post if the current Pipeline’s or status is failure, unstable, or aborted and the previous run was successful.  
`aborted`  
Only run the steps in post if the current Pipeline’s run has an "aborted" status, usually due to the Pipeline being manually aborted. This is typically denoted by gray in the web UI.  
`failure`  
Only run the steps in post if the current Pipeline’s or stage’s run has a "failed" status, typically denoted by red in the web UI.  
`success`  
Only run the steps in post if the current Pipeline’s or stage’s run has a "success" status, typically denoted by blue or green in the web UI.  
`unstable`  
Only run the steps in post if the current Pipeline’s run has an "unstable" status, usually caused by test failures, code violations, etc. This is typically denoted by yellow in the web UI.  
`unsuccessful`  
Only run the steps in post if the current Pipeline’s or stage’s run has not a "success" status. This is typically denoted in the web UI depending on the status previously mentioned (for stages this may fire if the build itself is unstable).  
`cleanup`  
Run the steps in this post condition after every other post condition has been evaluated, regardless of the Pipeline or stage’s status.  


-Tạo timeout cho pipeline: Cho phép ta giới hạn thời gian mà 1 pipeline được phép build. Điều này ngăn tình trạng vì 1 lý do nào đó mà 1 pipeline chạy vô thời hạn, Dẫn đến tốn tài nguyên.
Dashboard -> any branch -> pipeline syntax -> Declarative Directive Generator -> Sample directive: option -> timeout -> generate ra dòng lệnh
VD:
Option {
	Timeout(time: 1, unit: ‘second’)
}



-Checkout SCM
script:
git credentialsId: '<gitlab-credential>', url: ‘<url>' -> checkout nhánh master
git branch: 'dev', credentialsId: '<gitlab-credential>', url: '<url>' -> checkout các nhánh khác

Lưu ý: script này tương tự option Pipeline script from SCM trong config pipeline, do đó chỉ cần dùng 1 trong 2

[Image](https://drive.google.com/file/d/1-bAmYA8Ccr-fFBqGdNTCUfWWy1p_jPfB/view?usp=sharing)
