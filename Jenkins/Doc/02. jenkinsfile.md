### Cấu trúc Jenkins file

#### Jenkins file có thể viết theo kiểu Declarative hoặc Scripted

| Tiêu chí                  | Declarative Pipeline                                     | Scripted Pipeline                                       |
|---------------------------|---------------------------------------------------------|--------------------------------------------------------|
| **Cú pháp (Syntax)**        | Sử dụng cú pháp DSL có cấu trúc rõ ràng, bắt đầu bằng `pipeline {}` với các phần như `agent`, `stages`, `steps`, `post`. | Sử dụng Groovy script thuần túy, bắt đầu với `node {}`, có thể viết script linh hoạt bất cứ đâu. |
| **Tính linh hoạt**           | Ít linh hoạt hơn, giới hạn trong cấu trúc được định nghĩa sẵn, khó thực hiện logic phức tạp hoặc tùy biến sâu. | Rất linh hoạt, có thể tùy chỉnh mọi logic, điều kiện, vòng lặp phức tạp, xử lý lỗi nâng cao. |
| **Xử lý lỗi và kiểm tra**     | Hỗ trợ xử lý lỗi và thông báo lỗi sớm khi cấu trúc sai, dễ phát hiện lỗi ngay khi build. | Xử lý lỗi thủ công, lỗi có thể chỉ xuất hiện tại runtime của bước lỗi mà không báo từ đầu. |
| **Khả năng tái sử dụng code** | Tập trung vào cấu trúc chuẩn, ít code tái sử dụng phức tạp. | Dễ tái sử dụng và modular hóa code nhờ khả năng viết script Groovy tùy biến. |
| **Cách kết hợp**              | Có thể chèn Scripted Pipeline dùng directive `script {}` trong Declarative khi cần. | Không cần kết hợp, là dạng thuần script. |


#### Cấu trúc cơ bản của một Jenkinsfile theo kiểu Declarative Pipeline thường gồm các phần chính như sau:

```groovy
pipeline {
    agent {label 'agent-label'}  // Chỉ định môi trường để chạy pipeline (có thể là any hoặc none)
    
    environment {  // Khai báo các biến môi trường (nếu cần)
        VAR_NAME = "value"
        DOCKERHUB_CREDENTIAL=credentials{'dockerhub'}
        NAME = 'JENKINS'
    }

    stages {  // Tập hợp các giai đoạn (stage) trong pipeline
        stage('Stage Name') {
            steps {  // Các bước thực thi trong từng stage
                // Ví dụ: chạy lệnh shell
                sh 'echo Hello World'  
            }
        }
        // Có thể có nhiều stage như Build, Test, Deploy, ...
    }
    
    post {  // Các hành động được thực hiện sau khi pipeline hoặc stage kết thúc
        always {
            cleanWs()  // Ví dụ: dọn dẹp workspace sau khi chạy xong
        }
    }
}
```

---

Trong Jenkinsfile kiểu Declarative Pipeline, cú pháp và cấu trúc được quy định rõ ràng nhằm giúp pipeline dễ đọc, dễ bảo trì và giảm lỗi. Tuy nhiên, Declarative pipeline cũng cho phép bạn chèn một đoạn Scripted Pipeline vào bên trong bằng cách dùng directive script {}.
script {} là một khối đặc biệt trong Declarative Pipeline, cho phép bạn viết mã Groovy thuần theo kiểu Scripted Pipeline ngay bên trong pipeline.

Khi cần thực hiện các thao tác phức tạp mà Declarative Pipeline không hỗ trợ hoặc rất khó thực hiện do giới hạn cú pháp, bạn có thể sử dụng script {} để viết mã tùy chỉnh.
```
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                echo 'This is declarative step'
                
                script {
                    // Code Groovy kiểu scripted pipeline ở đây
                    def today = new Date()
                    echo "Today's date is ${today}"
                    
                    if (today.day == 1) {
                        echo 'Today is the first day of the month!'
                    }
                }
            }
        }
    }
}
```


Bạn hoàn toàn có thể đặt một đoạn bash script vào trong Jenkins Pipeline và chạy nó bình thường.

Trong Jenkinsfile, để chạy bash script trên môi trường Linux/Unix, bạn dùng step sh. Ví dụ:


```
pipeline {
    agent any
    stages {
        stage('Run Bash Script') {
            steps {
                sh '''
                #!/bin/bash
                echo "Hello from bash script"
                ls -l
                '''
            }
        }
    }
}
```

Từ khóa sh dùng để chạy shell script trên node Jenkins agent.

Bên trong phần script bạn có thể ghi nhiều dòng lệnh bash như trong terminal, bao gồm khai báo #!/bin/bash nếu muốn.

Bạn cũng có thể gọi trực tiếp file script .sh có sẵn trong workspace, ví dụ:


sh './deploy.sh'





#### Giải thích chi tiết về Parameter

Parameter cho phép truyền các tham số người dùng vào thời điểm bắt đầu chạy pipeline  
<---> bổ sung thêm

#### Giải thích chi tiết về Environment

##### Scope của variable

Scope của variable trong Jenkins file có các điểm chính sau:
- Biến được khai báo bên trong một stage hoặc một node block chỉ có phạm vi (scope) trong block đó
- Nếu muốn biến dùng chung cho nhiều stage hoặc toàn pipeline, biến cần được khai báo bên ngoài các block đó, ví dụ ngay trong pipeline hoặc ở đầu Jenkinsfile.
- Biến khai báo trong một hàm hoặc closure có phạm vi nội bộ (local) của hàm đó, không thể truy cập bên ngoài trừ khi trả về.
- Có thể dùng từ khóa def để định nghĩa biến cục bộ trong phạm vi nhỏ, hoặc khai báo biến bên ngoài để biến toàn cục trong script.
- Trong scripted pipeline, biến toàn cục có thể dễ dàng được dùng lại giữa các bước, nhưng trong declarative pipeline cần chú ý cách và nơi khai báo để tránh lỗi phạm vi.

##### Dùng environment để lấy thông tin từ Credentials được lưu trong Jenkins config

Environment có thể giúp xử lý thông tin đăng nhập (credentials) một cách an toàn. Cụ thể trong phần khai báo biến môi trường (environment) của Jenkinsfile, có một phương thức đặc biệt gọi là credentials(). Phương thức này giúp lấy thông tin đăng nhập đã được Jenkins quản lý (được lưu trữ trong phần Credentials của Jenkins) một cách tiện lợi và an toàn.

Những loại thông tin đăng nhập được Jenkins hỗ trợ và có thể dùng với phương thức credentials() bao gồm:
- Secret Text: Văn bản bí mật như token hoặc mật khẩu ở dạng chuỗi.
- Secret File: Tệp bí mật, ví dụ file chứa khóa bảo mật.
- Username and password: Cặp tên người dùng và mật khẩu.
- SSH with Private Key: Khoá riêng SSH dùng để xác thực cho việc kết nối qua SSH.

Example

```Groovy
pipeline {
    agent any
    environment {
        // Lấy username và password từ Jenkins Credentials có ID 'my-credentials-id'
        MY_CREDENTIALS = credentials('my-credentials-id')
    }
    stages {
        stage('Example Username/Password') {
            environment {
                SERVICE_CREDS = credentials('my-predefined-username-password') // Environment có thể đặt trong khổi pipeline hoặc khối stages
            }
            steps {
                sh (script: """echo Service user is $SERVICE_CREDS_USR """, label: "description")
                sh 'echo "Service password is $SERVICE_CREDS_PSW"'
                sh 'curl -u $SERVICE_CREDS https://myservice.example.com'
                sh 'echo "Using username: $MY_CREDENTIALS_USR"'
                sh 'echo "Using password: $MY_CREDENTIALS_PSW"'
            }
        }
        stage('Example SSH Username with private key') {
            environment {
                SSH_CREDS = credentials('my-predefined-ssh-creds')
            }
            steps {
                sh 'echo "SSH private key is located at $SSH_CREDS"'
                sh 'echo "SSH user is $SSH_CREDS_USR"'
                sh 'echo "SSH passphrase is $SSH_CREDS_PSW"'
            }
        }
        stage('Example Secret Text or Secret File') {
            environment {
                SECRET_TOKEN = credentials('my-secret-token-id')
            }
		}
    }
}


```

- Conditional trong Jenkin: Cho phép ta điều khiển luồng chạy của pipeline  
VD1: chỉ chạy stage deploy khi branch là develop
```
Stages {
	stage(‘deploy’) {
		When {
			Branch ‘develop’
		}
		Steps { command }
	}
}
```  
VD2: chỉ chạy stage deploy khi thỏa mãn tất cả các điều kiện trong khối allOf (hoặc anyOf là chỉ cần thỏa mãn 1 trong các điều kiện)  
```
Stages {
	stage(‘deploy’) {
		When {
			allOf {
				Branch ‘develop’
				Environment name: “ten_bien”, value: “gia_tri_bien”
			}
		}
		Steps { command }
	}
}
```
- Stages và Parallel: Cho phép ta lựa chọn thứ tự xử lý các task.  
    + Stages: xử lý tuần tự các task  
    + Parallel: xử lý đồng thời các task  

Các khối stages và parallel có thể nằm lồng trong nhau, tuy nhiên không thể tạo 1 khối parallel bên trong 1 khối stage mà khối stage đó đang nằm trong khối parallel khác  
VD1: 
```
Stages {
	stage(‘Read file’) {
		stages {
			stage(‘1’) {
				Steps{command}
			}
			stage(‘2){
				Steps{command}
			}
		}
	}
}
```
VD2:
```
Stages {
	stage(‘Build in’) {
		parallel {
			stage(‘1’) {
				Steps{command}
			}
			stage(‘2){
				Steps{command}
			}
		}
	}
}
```
- Tạo giai đoạn cuối cho mỗi pipeline (post-build actions): Cho phép ta tạo ra 1 bước cuối cùng ở mỗi stage/pipeline/. Thông thường, để dọn dẹp hoặc để gửi mail/notification thông báo là pipeline đã chạy xong. Khối post này có thể nằm trong khối stages, stage, pipeline,...

VD: Luôn hiển thị dòng finish kể cả có lỗi hay không
```
post {
	Always {
		Echo “finish”
	}
}
```
Ngoài always còn có changed, fixed, regression, aborted, failure, success, unstable, unsuccessful, and cleanup.  

`changed`  
Only run the steps in post if the current Pipeline’s run has a different completion status from its previous run.  
`fixed`  
Only run the steps in post if the current Pipeline’s run is successful and the previous run failed or was unstable.  
`regression`  
Only run the steps in post if the current Pipeline’s or status is failure, unstable, or aborted and the previous run was successful.  
`aborted`  
Only run the steps in post if the current Pipeline’s run has an "aborted" status, usually due to the Pipeline being manually aborted. This is typically denoted by gray in the web UI.  
`failure`  
Only run the steps in post if the current Pipeline’s or stage’s run has a "failed" status, typically denoted by red in the web UI.  
`success`  
Only run the steps in post if the current Pipeline’s or stage’s run has a "success" status, typically denoted by blue or green in the web UI.  
`unstable`  
Only run the steps in post if the current Pipeline’s run has an "unstable" status, usually caused by test failures, code violations, etc. This is typically denoted by yellow in the web UI.  
`unsuccessful`  
Only run the steps in post if the current Pipeline’s or stage’s run has not a "success" status. This is typically denoted in the web UI depending on the status previously mentioned (for stages this may fire if the build itself is unstable).  
`cleanup`  
Run the steps in this post condition after every other post condition has been evaluated, regardless of the Pipeline or stage’s status.  


-Tạo timeout cho pipeline: Cho phép ta giới hạn thời gian mà 1 pipeline được phép build. Điều này ngăn tình trạng vì 1 lý do nào đó mà 1 pipeline chạy vô thời hạn, Dẫn đến tốn tài nguyên.
Dashboard -> any branch -> pipeline syntax -> Declarative Directive Generator -> Sample directive: option -> timeout -> generate ra dòng lệnh
VD:
Option {
	Timeout(time: 1, unit: ‘second’)
}



-Checkout SCM
script:
git credentialsId: '<gitlab-credential>', url: ‘<url>' -> checkout nhánh master
git branch: 'dev', credentialsId: '<gitlab-credential>', url: '<url>' -> checkout các nhánh khác

Lưu ý: script này tương tự option Pipeline script from SCM trong config pipeline, do đó chỉ cần dùng 1 trong 2

[Image](https://drive.google.com/file/d/1-bAmYA8Ccr-fFBqGdNTCUfWWy1p_jPfB/view?usp=sharing)
