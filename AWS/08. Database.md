# RDS

RDS Oracle instance là một thực thể cơ sở dữ liệu riêng biệt do dịch vụ Amazon RDS quản lý, chạy engine Oracle trong môi trường đám mây AWS. Mỗi instance có cấu hình tài nguyên riêng (CPU, RAM, storage) và là nơi lưu trữ dữ liệu cũng như xử lý các truy vấn từ ứng dụng.​

Một RDS instance là một cơ sở dữ liệu hoạt động độc lập mà bạn có thể kết nối trực tiếp để đọc và ghi dữ liệu.

Nó không giống với Read Replica. Read Replica là bản sao chỉ đọc của một instance chính, dùng để xử lý các truy vấn chỉ đọc, giảm tải cho instance chính và giúp tăng khả năng mở rộng đọc. Read Replica sao chép dữ liệu từ instance chính một cách không đồng bộ.​

Tóm lại, instance là thực thể cơ sở dữ liệu chính (có thể đọc và ghi), còn read replicas là các bản sao phụ chỉ để đọc, hỗ trợ phân phối tải đọc hiệu quả hơn.

Trong mô hình chuẩn, một database Oracle trong RDS thường chỉ chạy trên một instance chính.

Để mở rộng hoặc tăng tính sẵn sàng, người dùng có thể tạo nhiều instance như read replicas hoặc standalone cho các mục đích như phân tải đọc, backup hoặc failover.

Scale trong AWS RDS Oracle:

- Scale đọc (Read Replica): Hỗ trợ tạo các read replicas để phân tải truy vấn đọc và tăng khả năng mở rộng đọc của hệ thống.​

- Vertical Scaling: Tăng cường tài nguyên cho instance như CPU, RAM, và lưu trữ thông qua thao tác thủ công hoặc tự động, phù hợp cho các tình huống cần tăng hiệu năng ngay lập tức.​


---


ACU là đơn vị đo “sức mạnh compute” mà Aurora Serverless v2 dùng để tính cả năng lực xử lý và chi phí. Mỗi ACU tương ứng khoảng 2 GiB RAM kèm CPU và mạng tỷ lệ với lượng RAM đó.​

Aurora Serverless v2 không dùng instance type (db.r6g.large, v.v.) mà dùng dải ACU, ví dụ 2–8 ACU, để quyết định tài nguyên được cấp cho database tại mỗi thời điểm.​

Mỗi ACU ~ 2 GiB bộ nhớ + phần CPU và network tương ứng, nên 8 ACU sẽ gần giống một máy có ~16 GiB RAM + CPU đủ mạnh để xử lý tải tương ứng.​


Aurora Serverless v2 tự động scale ACU lên/xuống theo tải thực tế (CPU, connection, I/O…), và có thể tăng/giảm theo bước 0.5 ACU nên rất mịn, tránh over‑provision nhiều.​ Bạn chỉ cấu hình min ACU và max ACU; trong khoảng đó, Aurora có thể scale trong mili‑giây mà không làm mất kết nối của ứng dụng, miễn là workload còn nằm trong dải cấu hình.​

Bạn trả tiền theo số ACU đang chạy trung bình theo giờ; càng nhiều ACU và càng chạy lâu (không scale xuống) thì bill càng cao.​

Do giá mỗi ACU khá cố định, tối ưu chi phí chủ yếu là: hạ min ACU khi idle, giữ max ACU đủ dùng, và để Aurora tự scale theo tải thay vì “dính” ở mức cao như 8 ACU suốt cả tuần.​

---

RDS PostgreSQL “thuần” (DB instance thông thường) không có cluster endpoint như Aurora, mà chỉ có endpoint cho từng DB instance (và nếu dùng Multi‑AZ DB cluster mới kiểu 2022 thì endpoint của cluster đó khác Aurora cluster endpoint truyền thống).
​

RDS PostgreSQL thông thường
- Kiểu triển khai phổ biến là single‑AZ hoặc Multi‑AZ DB instance, mỗi instance có một endpoint riêng (DNS name) dùng để kết nối.
​- Endpoint này không tự động load‑balance giữa nhiều reader như Aurora reader endpoint, nên nếu có read replica thì mỗi replica cũng có endpoint riêng.
​

Multi‑AZ DB cluster mới
- AWS có loại RDS Multi‑AZ DB cluster cho PostgreSQL với nhiều writer/reader node, loại này cung cấp cluster endpoint và các reader endpoint tương tự Aurora, nhưng đó là một option riêng khi tạo RDS, không phải “RDS Postgres thuần” mặc định


---
Lưu ý với AUrora Khi tạo Aurora PostgreSQL Serverless v2, mặc định nó chỉ tạo 1 writer instance trong 1 cluster, còn read instance là tùy chọn bạn bật thêm.

<img width="1565" height="252" alt="image" src="https://github.com/user-attachments/assets/308fd662-56f4-4da6-99a6-7d6496abf716" />

Trong ảnh thì
- buzz-ticket-production là DB cluster Aurora: nó đại diện cho cụm database (storage volume chung, endpoint dạng cluster-...) và chứa cấu hình chung như engine, version, capacity range, backup, v.v.​

- buzz-ticket-production-instance-1 là DB instance bên trong cluster đó: đây là compute node cụ thể (Serverless v2 2–256 ACUs) xử lý query, với endpoint riêng dạng instance endpoint.​

Lưu ý cluster sẽ có 2 endpoint (writer và reader), còn mỗi instance chỉ có 1 endpoint

Cluster endpoint:
- Writer endpoint: dùng cho đọc/ghi chính của ứng dụng, AWS tự chuyển hướng tới primary khi failover nên app không phải đổi hostname.
​- Reader endpoint: dùng cho các query chỉ đọc (reporting, analytics, high‑read traffic), Aurora tự load‑balance giữa các reader instance.
​
Instance endpoint:
- Dùng khi cần truy cập đúng một instance cụ thể để debug, tuning, chạy batch/report trên một instance riêng, hoặc khi tự thiết kế logic routing riêng (ví dụ qua ProxySQL).
​- Không nên hard‑code instance endpoint cho app chính vì khi failover role của instance có thể đổi (từ writer thành reader), dẫn tới lỗi hoặc không tối ưu.
​
Nếu app của bạn chỉ đơn giản là 1 writer + 1 reader, pattern chuẩn sẽ là: app dùng writer endpoint cho mọi write và phần lớn read quan trọng, còn các service/reporting dùng reader endpoint để chia tải.

---


Cluster metrics thường đo ở mức cụm: số kết nối tổng, replica lag, IOPS/throughput tổng, dung lượng storage, backup, v.v. và có thể gộp từ nhiều instance trong cluster (nếu có).​

Instance metrics đo tài nguyên compute của từng instance: CPU utilization, ACU đang dùng, memory, network, read/write IOPS mà instance đó xử lý, nên nếu sau này có thêm reader instance thì mỗi instance sẽ có đường metric riêng.​

Metric của buzz-ticket-production (cluster) và buzz-ticket-production-instance-1 (instance) có khác nhau kể cả khi cluster có 1 instance. Nguyên nhân là do ở mức cluster, một số metric là tổng/hàm tổng hợp và được tính theo logic riêng (ví dụ dựa trên volume, storage, I/O của toàn cụm), nên giá trị và tần suất ghi có thể khác metric ở mức instance, vốn đo trực tiếp CPU, ACU, network của buzz-ticket-production-instance-1.
​
Aurora còn có metric chỉ tồn tại ở cluster (ví dụ volume bytes used) hoặc chỉ tồn tại ở instance (ví dụ CPUUtilization, ACU usage)​

Các  metric có thể trùng tên nhưng namespace khác (Aurora/Cluster vs Aurora/Instance) và cách tính khác một chút, nên khi vẽ graph có thể lệch nhẹ hoặc khác hẳn (nhất là các metric về I/O, connection, latency); chỉ những metric thực sự “forward” từ instance lên cluster mới gần giống nhau

---

Amazon RDS Proxy là một dịch vụ quản lý kết nối trung gian dành cho cơ sở dữ liệu RDS, giúp tối ưu hiệu suất, bảo mật và khả năng mở rộng của ứng dụng khi kết nối với cơ sở dữ liệu. Tính năng:
- Quản lý pool kết nối hiệu quả, giảm tải cho DB. Thay vì kết nối trực tiếp đến endpoint của RDS, ứng dụng sẽ kết nối tới endpoint của RDS Proxy. Endpoint proxy sẽ giữ pool kết nối đến DB, giảm số kết nối mở tới DB thực. Proxy tự quản lý chuyển đổi kết nối trong trường hợp failover instance.
- Duy trì kết nối an toàn với IAM authentication hoặc Secrets Manager.
  - Có thể dùng IAM roles để ủy quyền proxy kết nối an toàn tới RDS.
  - Cấu hình AWS Secrets Manager để lưu trữ thông tin đăng nhập DB, proxy sẽ dùng để kết nối.
- Tự động chuyển hướng kết nối khi xảy ra failover.

RDS Proxy hỗ trợ một số engine như MySQL, PostgreSQL, SQL Server và Oracle. Với Oracle, RDS Proxy giúp giảm số lượng kết nối trực tiếp tới DB.

---

# AURORA
AWS Aurora cung cấp tính high availability (HA) vượt trội nhờ kiến trúc tách biệt storage và compute, đảm bảo dữ liệu luôn sẵn sàng ngay cả khi instance gặp sự cố. Dịch vụ tự động replicate dữ liệu đồng bộ sang 6 bản sao trên 3 Availability Zones (AZ), giúp tránh mất mát dữ liệu và giảm độ trễ trong backup. Thời gian failover thường dưới 60 giây, thường chỉ 30 giây, khi promote Aurora Replica thành primary instance.
​
## 1. Kiến trúc Storage HA
Aurora lưu trữ dữ liệu trên cluster volume chia sẻ, với 6 storage nodes (4 cho write, 3 cho read quorum). Mỗi write từ primary instance được replicate đồng bộ qua AZ, loại bỏ I/O freeze và đảm bảo redundancy. Tính năng tự heal ngang hàng cho phép phục hồi từ bản sao lành mạnh nếu một node hỏng.
​
​## 2. Aurora Replicas và Failover
Cluster hỗ trợ đến 15 read-only replicas (reader instances) sử dụng async replication, phân tải read traffic mà không ảnh hưởng writer. Trong failover, RDS ưu tiên promote replica có priority cao nhất (0-15), kích thước lớn nhất, giúp tăng availability qua Multi-AZ. Sử dụng RDS Proxy để giảm gián đoạn kết nối ứng dụng.
​
## 3. Global Database
Aurora Global Database mở rộng HA cross-Region: 1 primary Region + tối đa 5 secondary Regions với replication <1 giây. Failover secondary thành primary mất dưới 1 phút, lý tưởng cho DR toàn cầu

---

Nếu chỉ dùng 1 instance duy nhất trong AWS Aurora cluster (không có Aurora Replicas), cluster vẫn có nguy cơ downtime tạm thời khi instance gặp sự cố, nhưng dữ liệu không bị mất nhờ storage layer replicate 6 bản sao qua 3 AZ. Aurora sẽ tự động recreate instance mới trong cùng AZ (thường mất dưới 10 phút), gây gián đoạn read/write, hoặc nếu AZ outage thì cần manual tạo instance mới ở AZ khác. Để tránh downtime, khuyến nghị thêm ít nhất 1-2 Aurora Replicas ở các AZ khác nhau, giúp failover nhanh dưới 60 giây (thường 30 giây).
​
---

Aurora có tính năng tự động scale read replicas (cần enable).
​

- dùng auto scaling để tự tăng/giảm số lượng Aurora Replicas (reader instance) dựa trên metric như CPU trung bình, số connection, v.v. Bạn cấu hình min/max số reader (ví dụ min=0, max=5) và target metric (ví dụ CPU readers ~ 70%), hệ thống sẽ tự tạo thêm reader khi vượt ngưỡng và tự xoá bớt khi tải giảm để không tốn tiền instance nhàn rỗi.
- Tính năng này hợp khi workload read-heavy và biến động mạnh (ban ngày đọc nhiều, ban đêm ít) để vừa đảm bảo hiệu năng vừa tiết kiệm chi phí.


- aurora có khái niệm cluster endpoint (kể cả có tạo 1 instance)
- còn rds thường ko có cluster endpoint
- tạo aurora (provisioned/serverless) không cần define dung lượng storage (aws tự động)
-
---

## Terraform
Để tạo Database trên AWS, có 3 loại resource cần chú ý
- aws_rds_cluster: tạo “cluster” Aurora (dùng cho Aurora) 
- aws_rds_cluster_instance: tạo “instance” trong cluster Aurora
- aws_db_instance: tạo “classic RDS instance” (dùng cho các engine như MySQL/PostgreSQL/SQL Server không dùng Aurora).

### aws_rds_cluster để tạo Cluster Aurora
- Resource này mô tả một RDS Aurora cluster, tức là một cụm Aurora (Auto Scaling + Replication + Shared Storage).
- Ví dụ:​
```
resource "aws_rds_cluster" "aurora" {
  cluster_identifier      = "my-aurora-cluster"
  engine                  = "aurora-mysql" #Valid Values: aurora-mysql, aurora-postgresql, mysql, postgres. (Lưu ý mysql và postgres là Multi-AZ RDS clusters).
  engine_version          = "8.0.mysql_aurora.3.04.0"
  master_username         = "admin"
  master_password         = "..."
  db_subnet_group_name    = aws_db_subnet_group.rds.name
  vpc_security_group_ids  = [aws_security_group.db.id]
  # Các cài đặt khác: backup, parameter group, ...
}
```

### aws_rds_cluster_instance → Instance trong cluster Aurora
- Resource này mô tả một RDS instance nằm trong một Aurora cluster, tức là một “node” trong cluster Aurora (Primary hay Replica).
- Mỗi instance là một máy chủ (DB instance) chạy trên một Availability Zone, gắn vào cluster đã định nghĩa ở aws_rds_cluster.
- Có thể tạo nhiều aws_rds_cluster_instance để có nhiều Replica (reader) và 1 Primary (writer).
- aws_rds_cluster_instance chỉ dùng cho Aurora, không dùng cho các engine thông thường như MySQL/PostgreSQL “classic”.
- Ví dụ:
```
resource "aws_rds_cluster_instance" "primary" {
  identifier          = "primary-instance" #chỉ định resource aws_rds_cluster nào nó thuộc về.
  cluster_identifier  = aws_rds_cluster.aurora.id
  instance_class      = "db.r6.large"
  engine              = "aurora-mysql" #thường lấy từ cluster, nhưng có thể override nếu cần.
}

resource "aws_rds_cluster_instance" "replica" {
  identifier          = "replica-instance"
  cluster_identifier  = aws_rds_cluster.aurora.id
  instance_class      = "db.r6.large"
  engine              = "aurora-mysql" #thường lấy từ cluster, nhưng có thể override nếu cần.
  promotion_tier      = 1  # replica tier
}
```
### aws_db_instance → Classic RDS Instance
- Resource này mô tả một RDS instance kiểu “classic” (single instance, hoặc multi‑AZ) cho các engine thông thường như MySQL, PostgreSQL, SQL Server, Oracle, v.v..
- Dùng cho các engine không phải Aurora, ví dụ: mysql (MySQL standalone), postgres (PostgreSQL standalone), sqlserver-ee (SQL Server), oracle-ee (Oracle)
- Dùng aws_db_instance này khi không cần Aurora (tức không cần shared storage, replication Aurora, Auto Scaling replica tự động)
- Ví dụ
```
resource "aws_db_subnet_group" "rds" {
  name       = "rds-subnet-group"
  subnet_ids = ["subnet-xxx", "subnet-yyy"]  # private subnets
}

resource "aws_db_instance" "postgres" {
  identifier        = "my-postgres"
  engine            = "postgres"      # required
  engine_version    = "15.4"          # tuỳ chọn nhưng nên set
  instance_class    = "db.t3.micro"   # required
  allocated_storage = 20              # required
  username          = "dbadmin"
  manage_master_user_password           = true # trigger RDS tạo secret để quản lý password. Secret có format: {"username": "dbadmin", "password": "...", "engine": "postgres", "host": "..."}. Password tự động rotate mỗi 7 ngày
  master_user_secret_kms_key_id         = aws_kms_key.rds_secrets.key_id #nếu không chỉ định thì sẽ dùng default KMS key của Secrets Manager (alias aws/secretsmanager)
  db_subnet_group_name   = aws_db_subnet_group.rds.name # optional, nhưng nên set để đảm bảo DB nằm trong subnet private đúng ý, tránh default VPC.
  vpc_security_group_ids = [aws_security_group.rds.id]
  publicly_accessible    = false      # nên set false cho production, true chỉ cho lab / demo.

  # Lifecycle
  backup_retention_period = 7         # tuỳ chọn
  deletion_protection     = true      # tuỳ chọn
  skip_final_snapshot     = true      # tuỳ chọn, nhưng hay dùng trong dev

  # Khác
  multi_az            = false         # tuỳ chọn, dùng để bật tính năng HA
  availability_zone   = ["az1","az2"] # tùy chọn, để chỉ định AZ
  storage_type        = "gp3"         # tuỳ chọn
  max_allocated_storage = 100         # tuỳ chọn để bật autoscaling dung lượng
}

# Output Secret ARN để lấy arn của password (Password không lưu plaintext trong Terraform state, chỉ secret ARN).
output "rds_master_secret_arn" {
  value = aws_db_instance.postgres.master_user_secret[0].secret_arn
}

# Hoặc dùng data source để lấy thông tin của secret dựa trên secret_id
data "aws_secretsmanager_secret_version" "db_master" {
  secret_id = aws_db_instance.postgres.master_user_secret[0].secret_arn
}

# Tạo biến để chứa secret string
locals {
  db_master_creds = jsondecode(data.aws_secretsmanager_secret_version.db_master.secret_string)
}

# Format của secret_string với Aurora/RDS-managed secret thông thường là JSON:
{
  "engine": "postgres",
  "host": "xxx.rds.amazonaws.com",
  "username": "admin",
  "password": "....",
  "dbClusterIdentifier": "example"
}

# Lấy password để truyền cho resource khác:
resource "kubernetes_secret" "db_credentials" {
  metadata {
    name = "db-credentials"
  }

  data = {
    username = base64encode(local.db_master_creds.username)
    password = base64encode(local.db_master_creds.password)
  }
}
```
