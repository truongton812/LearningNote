# Amazon Elastic Container Service - ECS

## 1. Khái niệm
- Là dịch vụ quản lý container của AWS
- Trong đó:
  - ECS cluster: là 1 logical group chứa service hoặc task, cần phải tạo khi muốn sử dụng ECS
  - Task: là đơn vị triển khai nhỏ nhất để chạy một workload (ứng dụng, dịch vụ, batch job, v.v.) trên ECS cluster. Mỗi task được tạo dựa trên một task definition
  – Task definition: là template khai báo các container, cấu hình CPU, memory, network, IAM role, port, volume, môi trường biến môi trường. Một task definition có thể chứa một hoặc nhiều container (thường là các microservice hoặc các sidecar container đi kèm).​
  - Service: là thành phần giúp triển khai, quản lý và tự động duy trì số lượng các task dựa trên một task definition chỉ định, bất kể có sự cố hay sự thay đổi tài nguyên. Nếu một task bị thất bại hoặc bị ngắt, ECS sẽ tự động khởi động lại để duy trì số lượng yêu cầu.​ Service có option để đăng ký các task vào ELB, giúp phân phối traffic và đảm bảo tính sẵn sàng cao.​ Ngoài ra Service còn có cơ chế scaling tự động, ví dụ tăng giảm số lượng task khi traffic tăng hoặc giảm.

<img width="800" height="348" alt="image" src="https://github.com/user-attachments/assets/e84fb4d7-9296-404a-aa7c-a41531b1f09f" />

## 2. ECS Launch type

Amazon ECS có hai loại launch type chính để chạy container là Fargate và EC2, mỗi loại có cách quản lý tài nguyên và phù hợp với những trường hợp sử dụng khác nhau.

### 2.1. Fargate Launch Type
- Là giải pháp serverless cho container: người dùng không cần quản lý hạ tầng, EC2 instance hay cluster, AWS sẽ tự động cấp phát tài nguyên (CPU, bộ nhớ) theo yêu cầu từng task, tự scale lên/xuống và bảo trì hạ tầng.​
- Khi sử dụng Fargate Launch Type thì mỗi task sẽ có 1 IP riêng (cả IP public và IP private), truy cập thông qua IP của task, và port là port của container chứ ko phải ngẫu nhiên. Lưu ý nếu hết ip private trong VPC thì không thể tạo thêm task mới. Với Fargate Launch Type thì không thể xem log bằng lệnh docker logs được mà chỉ có thể xem trên giao diện
- Thanh toán dựa trên số lượng CPU, memory mà task sử dụng thực tế – tối ưu cho những workload thay đổi linh hoạt và không muốn vận hành hệ thống máy chủ.
- Hạn chế: không hỗ trợ GPU, chỉ tích hợp với EFS, không hỗ trợ EBS volume, DaemonSet/privileged container, không kiểm soát loại instance vật lý phía dưới. Resource tối đa AWS cung cấp cho task Fargate là 16 vCPU và 120GB RAM. Registry có thể sử dụng là ECR và docker-hub. Cost cao hơn EC2 nếu cluster được sử dụng hiệu quả toàn bộ tài nguyên.

### 2.2. EC2 Launch Type
- Sử dụng các EC2 instance do người dùng chủ động tạo và quản lý: chọn loại máy chủ, kiểm soát OS, cài đặt network, cấu hình bảo mật, storage, patch, v.v.​ Người dùng cần tự quản lý scaling cluster (thường dùng Auto Scaling Group), triển khai, vá lỗi, tối ưu khi sử dụng nhiều ứng dụng hoặc cần các chức năng đặc biệt như GPU, Disk EBS, FSx v.v.
- Khi sử dụng EC2 launch type thì các task có thể nằm chung trong 1 EC2 instance, muốn truy cập phải thông qua IP của EC2 instance + port được cấp ngẫu nhiên
- Khi sử dụng EC2 Launch Type thì cần cài ECS container agent lên mỗi EC2 trong ECS cluster (nếu sử dụng Amazon ECS-optimized AMI thì agent sẽ được cài sẵn) để thiết lập và duy trì kết nối giữa EC2 instance với ECS cluster
- Thanh toán theo model chi phí EC2: trả tiền cho toàn bộ instance dù chỉ dùng một phần tài nguyên. Có thể dùng Spot, Reserved Instance hoặc Savings Plan để tối ưu chi phí nếu workload ổn định và nhiều.
- Registry có thể sử dụng là ECR,docker-hub và self-hosted
- Phù hợp cho ứng dụng yêu cầu hiệu năng cao, workload cố định hoặc có yêu cầu kỹ thuật đặc biệt (low-latency, bảo mật, tuỳ chọn custom kernel).

## 3. Task definition

- Là bản thiết kế (blueprint) của ứng dụng container muốn chạy.
- Task Definition là một tập tin cấu hình (dạng JSON) mô tả chi tiết về một hoặc nhiều container (tối đa 10) gồm: image Docker dùng, CPU, bộ nhớ, cổng mở, volume dữ liệu, và cách khởi chạy.
- Ví dụ về task definition
```
{
  "family": "webserver",
  "containerDefinitions": [
    {
      "image": "private-repo-domain/private-image-name:tag",
      "repositoryCredentials": {
        "credentialsParameter": "arn:aws:secretsmanager:region:account-id:secret:secret-name"
      },
      "memory": 100,
      "cpu": 99,
      "essential": true,
      "executionRoleArn": "arn:aws:iam::account-id:role/ecsTaskExecutionRole"
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          "awslogs-group"         = aws_cloudwatch_log_group.ecs_task_log.name
          "awslogs-region"        = var.aws_region
          "awslogs-stream-prefix" = "api"
        }
      }
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/prod-cot-game-cms-be",
          "awslogs-region": "ap-northeast-1",
          "awslogs-stream-prefix": "ecs",
          "awslogs-create-group": "true"
        },
    }
  ],
  "requiresCompatibilities": [
    "FARGATE"
  ],
  "networkMode": "awsvpc",
  "memory": "512",
  "cpu": "256"
  "secrets": [
    {
      "name": "DB_PASSWORD",
      "valueFrom": "arn:aws:ssm:region:account-id:parameter/parameter-name"
    }
  ]
}
```

- Giải thích y nghĩa các trường
  - "family": Nhóm task definition; có thể sử dụng để versioning.
  - "containerDefinitions": Định nghĩa thông số từng container, bao gồm tên, image, dung lượng RAM, CPU.
    - logDriver: "awslogs" -> log sẽ được đẩy trực tiếp lên CloudWatch Logs trên AWS thay vì log ghi ra stdout/stderr trên host
    - awslogs-group -> tên log group trên CloudWatch Logs mà container sẽ gửi log vào.
    - awslogs-region -> chỉ định region nơi CloudWatch Logs group tồn tại.
    - awslogs-stream-prefix -> thêm prefix cho log stream bên trong CloudWatch Logs. Khi chạy ECS, mỗi container sẽ tạo một log stream với tên dạng:  `<prefix>/<container-name>/<ecs-task-id>`. awslogs-stream-prefix sẽ giống nhau cho các container thuộc cùng task definition. AWS recommend dùng service name làm prefix để dễ trace log về đúng service trong CloudWatch.
  - "repositoryCredentials": ARN của secret chứa credential AWS Secrets Manager. Secret này chứa thông tin để đăng nhập private repository. Lưu ý cần cấp executionRole có đủ quyền đọc secret cho container
  - "requiresCompatibilities": Chọn loại hạ tầng chạy container (ví dụ FARGATE, EC2, có thể chọn cả 2). -> khi triển khai task thì sẽ chọn để triển khai lên EC2 hay fargate hay cả 2
  - "networkMode": Chọn kiểu mạng (awsvpc, host mode hoặc bridge mode)
  - "memory" và "cpu": Dung lượng tổng cho Task definition.​
  - "secrets": định nghĩa biến môi trường trong container sẽ lấy giá trị từ Parameter Store.
  - Có thể custom thêm các trường như portMappings, environment, hoặc gắn volume theo nhu cầu

- Mẹo: nếu tạo task definition bằng giao diện console mà chọn EC2/fargate mà sau đấy muốn update bằng giao diện console thì sẽ không được, nếu muốn update thì dùng option "create new revision with json"

## 4. Capacity provider 
- Là thành phần giúp quản lý và tự động cung cấp tài nguyên tính toán (compute resources) cho cluster ECS
- Capacity provider cho phép ECS tự động scale in/out các tài nguyên phía sau như EC2 hoặc Fargate dựa theo nhu cầu hoạt động của task và service. Capacity provider giúp tối ưu hóa chi phí và hiệu suất, đảm bảo ứng dụng luôn có tài nguyên đủ để hoạt động nhưng không lãng phí.
- Các type Capacity Provider:
  - FARGATE/FARGATE_SPOT: sử dụng tài nguyên serverless của Fargate. Lưu ý khi tạo ECS Cluster với Infrastructure là Fargate thì mặc định Capacity Provider FARGATE và FARGATE_SPOT sẽ được thêm vào. Do ECS Cluster luôn có ít nhất 1 Infrastructure là Fargate nên có thể hiểu là mặc định 1 Cluster luôn có 2 Capacity Provider là FARGATE và FARGATE_SPOT, bạn không thể modify 2 Capacity Provider này 
  - EC2 Auto Scaling: Sử dụng một nhóm EC2 Auto Scaling do bạn tự quản lý hoặc do ECS tạo ra. ECS sẽ liên kết với ASG, hỗ trợ tự động scale in/out EC2 instance phục vụ cho workload container tương ứng
  - ECS Managed Instances: Giải pháp mới nhất kết hợp ưu điểm của Fargate (serverless, ít vận hành) với EC2 (kiểm soát instance, gắn tài nguyên mạng, storage...). AWS tự vận hành, cập nhật và scale hệ thống EC2 phía sau cho bạn.
- Có thể chỉ định nhiều capacity provider cho một ECS cluster và khi tạo service/task có thể thiết lập strategy để sử dụng 1 hoặc nhiều capacity provider và đặt weight/base cho từng loại
- Capacity provider thường dùng để chia workload giữa nhiều nhóm EC2 (khác cấu hình, khác pricing model, v.v.) hoặc giữa Fargate và Fargate Spot.​


### 4.1 Compute Option

Khi tạo một Service/Task mới sẽ thấy trường "Compute option" có hai lựa chọn là Capacity Provider Strategy và Launch Type 

#### 4.1.1. Capacity Provider Strategy
- Là cách quản lý tài nguyên compute dựa trên các capacity provider. Thay vì chọn loại launch riêng lẻ, người dùng cấu hình nhiều capacity provider và chiến lược phân bổ tài nguyên cho phù hợp với mục tiêu về hiệu suất, chi phí hoặc ngân sách. Ví dụ có thể tạo một strategy kết hợp FARGATE và FARGATE_SPOT (có thể lựa chọn tỷ lệ triển khai) để cân bằng chi phí trong service chạy serverless
- Lưu ý: được phép mix nhiều capacity provider của cùng nhóm Fargate (FARGATE & FARGATE_SPOT) hoặc mix nhiều capacity provider của nhóm ASG (ví dụ các ASG khác nhau). Nhưng không thể mix giữa Fargate với ASG

#### 4.1.2. Launch Type 

Là lựa chọn đơn giản hơn để xác định cách ECS sẽ triển khai container, chỉ có thể chọn 1 trong 3 loại launch type:
- EC2: Các task chạy trên các instance EC2 tự quản lý, phù hợp khi muốn kiểm soát trực tiếp phần cứng hoặc tối ưu chi phí.
- Fargate: Chạy container serverless, ECS sẽ tự quản lý hạ tầng compute, phù hợp cho các ứng dụng không muốn quản lý server hoặc muốn mở rộng linh hoạt.
- External: Chạy task trên on-prem server hoặc cloud provider khác

### 4.2 Debug
Khi ECS Service dùng capacity provider là ASG bị "pending" thì nguyên nhân thường là do:
- Chưa có Container Instance EC2 sẵn sàng/đăng ký vào cluster: Nếu ASG chưa provision EC2 hoặc EC2 khởi tạo nhưng chưa đăng ký thành công với ECS cluster (ví dụ ECS Agent chưa chạy, launch template sai, instance dùng AMI không tối ưu cho ECS), service sẽ mãi ở trạng thái pending vì không có tài nguyên để khởi chạy task.​
- ECS Agent trên EC2 bị lỗi hoặc không khởi chạy: Instance EC2 phải chạy ECS Agent với đủ quyền (ecsInstanceRole) mới đăng ký vào ECS cluster và nhận task. Nếu ECS Agent bị lỗi hoặc chưa khởi động, EC2 sẽ không hiện là container instance và ECS service không thể chạy task.​
- EC2 Instance thiếu quyền hoặc cấu hình networking lỗi: Instance cần có IAM role ecsInstanceRole. Nếu instance đặt ở private subnet thì phải đảm bảo có NAT Gateway, network access ra Internet/đến ECS API endpoint, và Security Group/NACL cho phép outbound traffic.

## 5. Task execution role và task role
### 5.1. Task execution role
- Dùng để cấp quyền cho ECS agent hoặc Fargate agent thực hiện các thao tác liên quan đến việc khởi tạo và vận hành task, ví dụ: pull image từ ECR, ghi log lên CloudWatch Logs, truy cập vào Secrets Manager/Parameter Store để inject secret, lấy thông tin registry private, v.v.​
- Role này được tham chiếu trong task definition và được ECS/Fargate agent assume khi thực thi nhiệm vụ trên hạ tầng, chứ không phải bản thân ứng dụng container.
- Policy phổ biến là AmazonECSTaskExecutionRolePolicy. Nếu ứng dụng cần truy cập tài nguyên AWS khác (S3, DynamoDB...) thì phải cấu hình ở task role, không phải ở execution role.

### 5.2. Task role
- Phục vụ cho chính các ứng dụng/chương trình chạy bên trong container khi cần truy cập tài nguyên AWS (S3, DynamoDB, SNS, SQS, ...).
- Role này cũng được khai báo trong task definition, khi task container chạy thì AWS cấp tạm thông tin truy cập để container đó assume role này và dùng AWS SDK/CLI với quyền đã cấp phát.​
- Có thể định nghĩa nhiều task role để chia nhỏ quyền cho từng loại workload/task khác nhau nhằm tuân thủ principle of least privilege.

## 6. ECS Network

ECS hỗ trợ ba chế độ network chính để chạy container: awsvpc, bridge, và host. Mỗi chế độ kết nối mạng sẽ phù hợp với các yêu cầu kỹ thuật và launch type khác nhau.

> Trong thực tế Fargate chỉ cho phép awsvpc, còn với EC2 launch type, bạn có thể chọn giữa bridge, host, hoặc awsvpc tùy yêu cầu hiệu năng, bảo mật và khả năng mở rộng.​

### 6.1. awsvpc network mode
- Mỗi task hoặc mỗi nhóm container chạy cùng task được gán một Elastic Network Interface (ENI). ENI này là một card mạng ảo gắn trực tiếp vào task trong VPC, và task đó nhận một địa chỉ IP riêng biệt trong mạng VPC. Nhờ đó, mỗi task có thể giao tiếp mạng độc lập như một instance riêng, với địa chỉ IP riêng và có thể gán Security Group riêng.​
- Hỗ trợ tốt các tính năng bảo mật, networking của VPC (security group, subnet v.v.), thích hợp cho Fargate và những workload cần cô lập hoặc yêu cầu networking chặt chẽ.
- Đây là chế độ bắt buộc khi dùng launch type Fargate.​
- Nếu một task có 10 container chạy trên Fargate với chế độ mạng awsvpc, thì task đó chỉ có một ENI (Elastic Network Interface) duy nhất và tương ứng với một địa chỉ IP private trong VPC. Tất cả các container trong task sẽ chia sẻ chung ENI và địa chỉ IP này để giao tiếp mạng
- Nhược điểm: chiếm tài nguyên nhiều hơn (mỗi task thêm 1 ENI).
  
### 6.2. bridge network mode
- Các container chia sẻ cùng một mạng "bridge" trên EC2 instance và giao tiếp qua forwarding port giữa host và container.
- Dựa trên cơ chế Docker bridge network. Mỗi container trong cùng một host sẽ kết nối qua một mạng ảo nội bộ (docker0 bridge).
- Cho phép port mapping động (ví dụ: container chạy port 80 nhưng ánh xạ thành port ngẫu nhiên trên host).
- Mặc định của Docker Engine truyền thống, phù hợp cho workload không yêu cầu địa chỉ IP riêng cho từng container.
- Được hỗ trợ khi chạy ECS với EC2 launch type, không áp dụng cho Fargate.​​
- Có thể run nhiều replicas của 1 task. Nhược điểm là dynamic port

### 6.3. host network mode
- Container dùng trực tiếp network interface của host EC2, không qua NAT hay bridge; port container sẽ là port của host.
- Ưu điểm: hiệu năng cao hơn Bridge (do bỏ qua lớp NAT). Nhược điểm: không thể chạy nhiều container cùng port trên cùng một host, vì trùng cổng sẽ xung đột.
- Chủ yếu dùng cho ứng dụng cần hiệu năng mạng cao hoặc khi cần tránh NAT/bridge, chỉ hỗ trợ với EC2 launch type.


## 7. Load balancing cho ECS

- Có thể đặt task ở public subnet, lúc đấy task sẽ có public IP và user có thể truy xuất task thông qua public IP. Có thể kết hợp thêm ELB để đẩy traffic thay vì phải nhớ từng ip của task. Tuy nhiên xét về mặt bảo mật, cách này là bad practice
- Best practice là đặt task ở private subnet và dùng ELB để forward traffic đến task

<img width="961" height="701" alt="image" src="https://github.com/user-attachments/assets/cce1903f-843f-4c95-a975-34977d2d4cdb" />

### Cách tạo LB cho ECS Fargate
- Với ECS Fargate, mỗi task chạy trong môi trường tách biệt (không có ENI cố định như EC2 instance chung), do đó ECS chỉ có thể đăng ký container IP vào target group. Vì thế target group bắt buộc phải chọn type là IP, không thể dùng type instance.
- Mà IP của task do AWS cấp động mỗi lần task khởi tạo, nên khi bạn tạo target group thì không thể biết trước IP để add thủ công.
  
⭢ Giải pháp là dùng target group mặc định (cách này cũng được nhưng hiện tại AWS đã update):
- Khi tạo Application Load Balancer (ALB), AWS yêu cầu cung cấp ít nhất một target group mặc định, để ALB có nơi nhận traffic khi không có rule nào match. Do đó ban đầu ta có thể tạo 1 target group trống (empty target group) để đáp ứng yêu cầu cấu hình ALB.
- Sau đó khi tạo ECS Service ta quy định Service sử dụng target group riêng cho route của mình (ví dụ `/`). ECS service sẽ tự động gắn (register) hoặc gỡ (deregister) IP của các task vào target group tương ứng khi task start/stop.
- ALB sẽ có rule theo dạng “if path = `/` thì forward đến target group của service”, còn nếu không match rule nào thì traffic sẽ được forward về target group mặc định (empty target group)

⭢ Cách trên cũng được nhưng hiện tại không cần tạo empty target group nữa, chỉ cần tạo target group type IP và chỉ định ECS Service thuộc target group đấy ⭢ tự động các task của Service sẽ được register vào LB

## 8. ECS Autoscaling
- Là tính năng tự động mở rộng quy mô trong Amazon Elastic Container Service (ECS), giúp điều chỉnh tài nguyên dựa trên nhu cầu ứng dụng mà không cần can thiệp thủ công.
- ECS Autoscaling bao gồm hai loại chính: Service Autoscaling (tự động điều chỉnh số lượng task cho dịch vụ) và Cluster Autoscaling (tự động mở rộng hạ tầng EC2 trong cluster).​

### 8.1. Service Autoscaling
- Service Autoscaling điều chỉnh số lượng task dựa trên các chỉ số như CPU, memory hoặc metric tùy chỉnh từ CloudWatch. Hỗ trợ các policy như Target Tracking (theo dõi mục tiêu), Step Scaling (tăng/giảm theo bước) và Scheduled Scaling (theo lịch). Ví dụ, khi tải tăng, nó tự động thêm task lên đến giới hạn tối đa, đảm bảo dịch vụ luôn sẵn sàng.​​
- Cách cấu hình Service Autoscaling: chọn cluster và service ⭢ "Service auto scaling". Đặt min/max task count và chọn `Scaling policy type` (Target Tracking hoặc Step Scaling) dựa trên CloudWatch alarms
  - Khi dùng Target Tracking policy thì có 3 metric cơ bản là ECSServiceAverageCPUUtilization (CPU trung bình của service), ECSServiceAverageMemoryUtilization (memory trung bình), và ALBRequestCountPerTarget (số request trung bình/phút trên ALB target). Có thể sử dụng custom metric cho Target Tracking bằng cách publish custom metric lên CloudWatch, sau đó chỉ định trong policy qua CustomizedMetricSpecification với MetricName, Namespace, Statistic, Unit, và TargetValue (Lưu ý CustomizedMetricSpecification chỉ khả dụng khi tạo policy qua AWS CLI, SDK hoặc CloudFormation, không qua Console)
  - Khi dùng Step scaling sẽ không bị giới hạn vào một tập metric cố định như target tracking, mà dựa trên bất kỳ CloudWatch alarm (người dùng tự tạo CloudWatch alarm dựa trên metric nào cũng được, sau đó trong policy định nghĩa các “step adjustments")
 
### 8.2. Cluster Autoscaling
- Khi sử dụng EC2 launch type cần có strategy để scale số lượng EC2 cho phù hợp - gọi là Cluster Autoscaling
- Có 2 strategy để thực thi Cluster Autoscaling
  - Dùng Auto Scaling Group để scale dựa trên lượng số CPU/Mem sử dụng
  - Sử dụng Capacity Provider để tự động thêm hoặc giảm EC2 instance khi số task vượt quá dung lượng hiện tại. 

---

ECS metric

Nếu enable Container insight thì có thêm nhiều metric hơn (mất phí)

---

## ECS log
- ECS task có thể gửi log trực tiếp vào CW (cần enable aws logs log driver bằng cách config "log configuration" parameter trong task definition)
```
{
  "family": "my-ecs-task",
  "containerDefinitions": [
    {
      "name": "my-app",
      "image": "nginx:latest",
      "essential": true,
      "memory": 512,
      "cpu": 256,
      "portMappings": [
        {
          "containerPort": 80,
          "hostPort": 80
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/my-app-logs",
          "awslogs-region": "ap-southeast-1",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```


- Nếu dùng fargate thì chỉ cấn gán ecstaskexecutionrole cho task. Support các logs driver khác như aws logs, splunk, awsfirelens
- Nếu dùng EC2 thì phải cài cloudwatch agent và gán role cho EC2 (cần 2 quyền là ECSContainerServiceforEC2Role và SSMManagedInstanceCore)  để có quyền push log lên cloudwatch. Nên đẩy log ra CW log để tránh đầy disk của EC2. Có thể kết hợp CW Unified Agent và ECS container agent. Cần sửa file config trong container /etc/ecs/ecs.config -> tìm đếm dòng ECS_AVAILABLE_LOGGING_DRIVERS
- Nếu không gửi log trực tiếp về CW thì ta có thể dùng sidecar container. Ý tưởng là có 1 container collect log ở stdout và file ở filesystem sau đó send vào storage (VD CW)

---



---

ECS có hỗ trợ deployment strategy là rolling update (default) , blue/green , canary và linear (lưu ý chỉ hoạt động ở service level)

Khi dùng blue/green thì ta cần tạo 2 target group cho ALB, 1 TG là để cho version blue, 1 TG là cho version green

Sau khi tạo xong service với deployment strategy là blue/green thì underlying sẽ tạo ra 1 application trong codedeploy (cần check lại) với deployment group trỏ về ecs service

Lưu ý deployment group chỉ giúp codedeploy biết nơi cần phải deploy ứng dụng, còn deploy ứng dụng nào thì cần phải khai báo trong file appspec.yaml -> sau khi khai báo file appspec.yaml thì codedeploy sẽ run luôn và version sẽ được thay đổi

Khi thực hiện blue/green deployment thì ALB sẽ shift traffic sang target group green, tuy nhiên vẫn giữ các task của blue version để ta có thể rollback. Mặc định blue/green cho ta thời gian chờ là 1 tiếng để có thể rollback về blue version.

Bên cạnh rollback thủ công, ta còn có thể kết hợp cloudwatch alarm để rollback (VD số lượng code 4xx 5xx cao thì rollback)

---

ECS architecture

- Cách invoke ECS:

Để invoke ECS có thể dùng EventBridge (trigger hoặc định kỳ):

```
          upload image/video        Send event        Invoke
client    --------------------> S3  ------------> EB ---------> ECS task ---------> DynamoDB
                                                                    |
                                                                    ---------------> S3
```
Note: để hoàn toàn serverless thì dùng fargate type
      có thể thay = lambda nhưng lambda chỉ max 15'

- Hoặc dùng SQS để invoke ECS

message ---------> SQS queue -----(poll)-----> ECS service auto scaling (task1, task2,... taskn) để đảm bảo task luôn chạy

- Để gửi notification thì dùng EB

  ECS tasks exited --- (event) ----> EB --------(trigger)--> SNS ----email------> Admin


---

### ECS - IAM role

- EC2 instance profile: chỉ dùng cho EC2 launch type, áp lên EC2 (thực ra là ECS agent), cho phép gọi API đến ECS Service / ECR (lấy image) / Cloudwatch log (gửi log container) / SSM parameter store (để lấy var)
- ECS task role: áp lên task , cho phép task làm gì (VD đọc S3/ DynamoDB,...). Mỗi task có 1 role, define trong task definition

### ECS Service
  - Service: là thành phần giúp triển khai, quản lý và tự động duy trì số lượng các task dựa trên một task definition chỉ định, bất kể có sự cố hay sự thay đổi tài nguyên. Nếu một task bị thất bại hoặc bị ngắt, ECS sẽ tự động khởi động lại để duy trì số lượng yêu cầu.​ Service có option để đăng ký các task vào ELB, giúp phân phối traffic và đảm bảo tính sẵn sàng cao.​ Ngoài ra Service còn có cơ chế scaling tự động, ví dụ tăng giảm số lượng task khi traffic tăng hoặc giảm.

---

khi tạo task dạng Fargate trên ECS, bạn có thể "exec" vào container của task để tương tác như với docker exec trên máy chủ bình thường nhờ tính năng ECS Exec của AWS.

```
aws ecs execute-command \
    --cluster your-cluster-name \
    --task your-task-id \
    --container your-container-name \
    --command "/bin/sh" \
    --interactive
```


Để exec được vào container thì cần gán role cho task/container (thông qua task role). Task role cần trust ecs-tasks.amazonaws.com và có quyền SSM (như ssmmessages:CreateControlChannel) để agent SSM trong container chấp nhận kết nối từ Systems Manager, do ECS Exec dùng SSM tạo kênh giao tiếp an toàn giữa CLI của bạn và container, không qua SSH trực tiếp. Lưu ý bản thân user cần có quyền ecs:execute-command để khởi tạo session exec

Policy Cần Thêm Vào Task Role
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ssmmessages:CreateControlChannel",
        "ssmmessages:CreateDataChannel",
        "ssmmessages:OpenControlChannel",
        "ssmmessages:OpenDataChannel"
      ],
      "Resource": "*"
    }
  ]
}
```

---

AWS VPC Endpoint cho Amazon ECR có 2 endpoint là com.amazonaws.ap-northeast-1.ecr.api và com.amazonaws.ap-northeast-1.ecr.dkr
- `com.amazonaws.ap-northeast-1.ecr.api` là endpoint cho API của Amazon ECR, dùng để thực hiện các thao tác điều khiển như tạo/xóa repo, tạo/xóa image, authen (VD khi dùng lệnh aws ecr get-login-password). Những lệnh này thường chạy trên EC2, CI/CD server, hoặc local chứ không phải trực tiếp từ ECS Task.
- `com.amazonaws.ap-northeast-1.ecr.dkr` là endpoint cho Docker registry API, dùng để thực hiện pull/push image, docker login,.. Nếu ECS task chỉ chạy container thì không bắt buộc phải dùng API endpoint, chỉ cần dùng docker endpoint

Trong nhiều kiến trúc VPC dùng ECR hoàn toàn nội bộ, người ta thường tạo đồng thời cả hai endpoint (ecr.api + ecr.dkr) kèm Gateway endpoint cho S3 để các layer image được tải từ S3 qua nội bộ VPC.

---

Khi sử dụng task definition với tag latest thì cần lưu ý ECS không tự động pull image mới nếu task definition không thay đổi. Khi đó nếu muốn update image của service trong AWS ECS thì có 2 cách:
- tạo task definition revision mới (có thể tạo task definition revision mới mà nội dung không thay đổi gì). Khi update service với task definition revision mới (dù nội dung giống hệt), ECS sẽ luôn pull (download) image mới nhất tương ứng với tag latest để tạo các task mới
- Dùng `--force-new-deployment` để kích hoạt deployment mới mà không cần tạo revision mới cho task definition. Option “Force new deployment” trong AWS ECS dùng để buộc service khởi động lại một đợt deployment mới, ngay cả khi không có thay đổi gì về task definition hay cấu hình service. Cách cập nhật qua AWS CLI `aws ecs update-service --cluster <cluster-name> --service <service-name> --force-new-deployment`. Cách cập nhật qua Console: Vào ECS > Clusters > Services > Chọn service > Update > tick Force new deployment

